                                             React Native
..............................................................................................

What is React Native?

1.React Native is lib for building native mobile apps 
2.React Native combines the best parts of native development with React, a best-in-class  JavaScript library for building user interfaces.

Mobile App development:

 Mobile apps are built using mobile platforms and os.

Mobile platforms:
1.Android
2.Ios

Mobile devices are acting front end devices, user interfaces communicates back end services.

Dev:
 1.user interface developer/front end developer
 2.back end developer
 3.full stack developer.

Front end developer who dev apps for  front devices.

Devices:
 1.computers - desktop
 2.Hand held devices- Mobiles,Tabs..
 3.TV,Game consoles
 4.IOT devices- It could be any - watches,car,industrial apps,

Dev generally build apps for desktops:
  Standalone desktop apps
  Browser based apps- javascript,html,css - react,angular,vue.....

Mobile /Tab apps:
 Dev builds apps for android platform using java , kotlin pl.
 in iOS development, you use Swift or Objective-C.

Types of mobile Apps:
.....................

1.Native Mobile
2.Web apps
3.Hybrid apps

1.Native Mobile
   Mobiles built by using native platform languages- java / Swift.
2.Web apps
   Apps built for browsers -Mobile browsers
3.Hybrid  apps
   built apps using javascript but it wont run inside browser, runs inside mobile using   container(WebView).


Hybrid apps:

 Application built using javascript,css,html,looks like native apps.

Why Hybrid Apps?

-incase native apps, we need to maintain two code base for both platform.

Why not to build one single portable app for all platforms?

 That is birth of hybrid apps.

Hybrids apps can be built using existing web tech- js,css,html.
Js is simple dom language, how to acess platform services such as contacts,networks,storage..
- a lib was created -cordova , based on cordova adobe started building a framework on top of the cordova , called phoneGap.

...........................................................................................

How to build mobile native apps in portable way using same javascript technology without html and css?

		That is birth of React Native.

/////////////////////////////////////////////////////////////////////////////////////

React Native Application Architecture :
...........................

React native applications are written using react(js) core principles
 -Components
 -Props
 -State
 -Event Handling
 -JSX

           "Every react native apps are simple javascript code"

 "In React Native, there is no webview concept. React native never run inside browser."
...............................................................................
			How react native works?


if you want to understand react native, we need to understand the source code react native.

we write code in react using jsx language.
jsx language mixes of html code + javascript 

1.UI MARK UP Code
   -  incase of react , html is mark up

UI Mark Up code for React native:

React native does not use html language to build ui elements.
React Native provides a high level ui components already written, so we can use those
components only.Why?
 We are building portable application either for android or ios.
So we need generic concept for both  platforms. 
For that React native provides a generic components for both platforms.

.....................................................................................
	   		 JSX Compilation Model
			     (browser)

                   layout.js / layout.jsx  -source code
		       |
		    compiler - babel.js 
			|
		    plain js code
			|-----------------------Dev cycle
	----------------------------------------- -- Excution cycles Starts
  Runtime : React Engine  compiled code feed into react engine
			|
		  Excute compiled js code : function calls
			|
	     create virtual Object tree (in browser V-dom)
		        |
		    Render Engine ; will convert react object tree into js dom object tree
			|
		   Flush the tree into target
			|
	--------------------------------------------
        |
       v8
     Browser			

React Native Compilation:

What is it? What is happening during compilation?

Source code is converted into another source code - Compilation.
Another code is platform specific code. android code or ios code.
if i  write ui components, ui components will be converted to platform spefic components.
javascript code will be emitted as it is-app code.



2.Application logic code
   - js code - apis,state,props......


1.Source Code
    written in react - UI Code and app logic

2.Compiled code
    code converted into platform specific code.

			React Native Source Code
			  (fileName.js or jsx)
				|
			     compiler
				|
		---------------------------------------------
		|                                           |
	  ui mark up                                  javascript code
		|
  compiled as platform specific code			   |
		|                                      Not Compiled
	-------------					   |
	|           |                                    
  Andorid          ios

-------------------------------------------------------------------------------------

Runtime Components:

1.All Views(User interface) elements are executed by "Platform runtimes"
2.All javascript code is exectued by javascript runtime.

Browsers:
 Chrome - V8
 Edge - Chakra
 FireFox -Spider Monkey


Hermes is an open-source JavaScript engine optimized for React Native
.....................................................................................
				How to build react native apps


There are two work flows 

1.Using React native lib
2.Using Expo framework


1.Using React native lib

React Native lib is core lib which offers core components for building native application development

if you want to build professional mobile app you need lot of infrastructure.
 UI Components
    -Views,Text,Labels,ListViews,ScrollView,TabView...........

React native core team provides all core components necessary to build mobile apps.

What if i want more components which is not supported by react core team.

You need to look at community or companies who provides professional mobile apps.

-Community -https://reactnative.directory/


2.Using Expo framework

 Expo  is a framwork built on the top of ReactNative core lib

What is expo?

 Expo is a framework and a platform for universal React native applications. It is a set of tools and services built around React Native and native platforms that help you develop, build, deploy, and quickly iterate on iOS, Android, and web apps from the same JavaScript/TypeScript codebase.

Expo Apps are created using 2 ways


Managed Work flow:

  With the managed workflow you only write JavaScript / TypeScript and Expo tools and services take care of everything else for you.

  The managed workflow is kind of like Rails and Create React App, but for React Native.

Apps are built with the managed workflow using the expo-cli, the Expo Go app on your mobile device, and our various services: push notifications, the build service, and over-the-air (OTA) updates. 

Expo tries to manage as much of the complexity of building apps for you as we can, which is why we call it the managed workflow.

 A developer using the managed workflow doesn't use Xcode or Android Studio, they just write JavaScript code and manage configuration for things like the app icon and splash screen through app.json.

 The Expo SDK exposes an increasingly comprehensive set of APIs that give you the power to access device capabilities like the camera, biometric authentication, file system, haptics, and so on.

Bare Work flow:

  In the bare workflow you have full control over every aspect of the native project, and Expo tools and services are a little more limited.

In the bare workflow the developer has complete control, along with the complexity that comes with that. You can use most APIs in the Expo SDK, but the build service and easy Configuration with app.json / app.config.js are not yet supported.

.....................................................................................

Running your React Native application in case of expo work flow:
.................................................................

1.You can run and test app inside browser itself- this is not recommended for complex apps.

2.You can run inside your device directly.
  Expo offers called expo client.
3.You can use emulators -Andorid virtual devices or emulators.

Metro Bundler:
-Online compiler, compiles code into react native 
....................................................................................
				Project setup

1.Using Reactive lib work flow

Requirements

-Windows - os
-Android 

Dependencies:
1.Node - 14+
2.JDK - 11

Open Cmd Prompt:

java --version
java 11.0.11 2021-04-20 LTS
Java(TM) SE Runtime Environment 18.9 (build 11.0.11+9-LTS-194)
Java HotSpot(TM) 64-Bit Server VM 18.9 (build 11.0.11+9-LTS-194, mixed mode)

node --version
v16.15.0


Kindly follow the Official documentation for installing necessary setups

1.Android studio
2.SDK
3.AVD Managers
https://reactnative.dev/docs/environment-setup

.....................................................................................

React Native Project setup.

npx react-native init ProjectName


Note:
 Before running npx command, if you have installed react-native cli via npm 
for eg:
npm install react-native-cli -g
You have to uninstall other wise it will give some error.

npm uninstall react-native-cli -g


npx react-native init myreactnativeApp

How to run app?
cd "E:\session\IBM\2022\july\ReactNative\myreactnativeApp" && npx react-native run-android
.....................................................................................
			   Expo Work flow Setup
....................................................................................


Expo work flow:
..............

Using npm

npm install expo-cli --global
expo init myNewProject
cd myNewProject
expo start

Using npx

npx create-expo-app my-app && cd my-app
.....................................................................................
				React Native Core Components
.....................................................................................

React Native offers lot of components but some components are core components.

Basic components:
..................

1.View
2.Text
3.Image
4.TextInput
5.ScrollView
6.StyleSheet

1.View:
.......
  The most fundamental component for building a UI, View is a container that supports layout with flexbox, style, some touch handling, and accessibility controls. View maps directly to the native view equivalent on whatever platform React Native is running on, whether that is a UIView, <div>, android.view, etc.


import { View } from "react-native";

//Root Component
function App() {
   return <View>
   </View>
}

export default App;

2.Text
	
A React component for displaying text.

Text supports nesting, styling, and touch handling.



import { Text, View } from "react-native";

//Root Component
function App() {
    return <View>
        <Text>
            Hello,React Native
        </Text>
        <Text>
            Hello,React Native
        </Text>
        <Text>
            Hello,React Native
        </Text>
    </View>
}

export default App;
.....................................................................................					 JSX basic Rules
....................................................................................

JSX follows XML rules for markup design.

1.In XML elements must organized under one parent element/root element, if not then it will throw error, same pattern is followed in react jsx as well.

Error code
<p>hai</p>
<p>hai</p>
  <Text>
            Hello,React Native
        </Text>
        <Text>
            Hello,React Native
        </Text>
        <Text>
            Hello,React Native
        </Text>

<div>
<p>hai</p>
<p>hai</p>
</div>
<View>
        <Text>
            Hello,React Native
        </Text>
        <Text>
            Hello,React Native
        </Text>
        <Text>
            Hello,React Native
        </Text>
    </View>

some times i dont want container elements.

React 16 onwards, it is possible to have without container elements, with help of fragements

Fragements are used to avoid unncessary view/div elements.
Fragements are invisible container component.

<React.Fragement>

<React.Fragment>
        <Text>
            Hello,React Native
        </Text>
        <Text>
            Hello,React Native
        </Text>
    </React.Fragment>

Short cut:

import React,{Fragment} from "react";
import { Text, View } from "react-native";

//Root Component
function App() {
    return <Fragment>
        <Text>
            Hello,React Native
        </Text>
        <Text>
            Hello,React Native
        </Text>
    </Fragment>
}

export default App;


import React, { Fragment } from "react";
import { Text, View } from "react-native";

//Root Component
// function App() {
//     return <View>
//         <Text>
//             Hello,React Native
//         </Text>
//         <Text>
//             Hello,React Native
//         </Text>
//     </View>
// }
const App = () => <View>
    <Text>
        Hello,React Native!
    </Text>
    <Text>
        Hello,React Native!!
    </Text>
</View>

export default App;
....................................................................................
			      React Native Styles
.....................................................................................

Styles:

React Native applications are platform independant: if android means, android spefic styles
should be applied, if ios means ios specific styles should be challenge.
                                                     
						     
 						      |----Android
 Common Style language/lib/framework----|build tool---|----IOS


CSS is style language for web -browsers.

Can we use CSS language for React Native?

No!.

React Native uses CSS INSIDE javascript:

In React

css
.box{
  background-color :'red'
 }

Way1
 <div className="box">

way 2

javascript style object
 <div style={ {backgroundColor:'red'} } />

javascript style object properties:
https://www.w3schools.com/jsref/dom_obj_style.asp


React Native style representation:

1.StyleSheet  is object through we can create styles and can be attached to any React native
elements.

Style can be applied in twos

1.inline style object
<View>

</View>

2.external style object
<View>

</View>


import { View, Text, StyleSheet } from "react-native"


// const App = () => {
//     // inline style 
//     return <View style={{backgroundColor:'pink'}}>
//         <Text>
//             Welcome to React Native
//         </Text>
//     </View>
// }

//external style object 
const styles = StyleSheet.create({
    backgroundColor: 'yellow'
})


const App = () => {
    // inline style 
    return <View style={styles}>
        <Text>
            Welcome to React Native
        </Text>
    </View>
}
export default App;
.....................................................................................
		    Styling Indivdual Components
....................................................................................

Component is collection of userinterface elements like view,text...

How to write style for View and Text separtely.

const styles = StyleSheet.create({
    container: { 
	 backgroundColor: 'yellow'
    }
})

eg:
import { View, Text, StyleSheet } from "react-native"


// const App = () => {
//     // inline style 
//     return <View style={{backgroundColor:'pink'}}>
//         <Text>
//             Welcome to React Native
//         </Text>
//     </View>
// }

//external style object 
// const styles = StyleSheet.create({
//     backgroundColor: 'yellow'
// })

const styles = StyleSheet.create({
    container: {
        backgroundColor: 'yellow'
    },
    text: {
        fontSize: 100,
        color: "red",
    }

})


const App = () => {
    // inline style 
    return <View style={styles.container}>
        <Text style={styles.text}>
            Welcome to React Native
        </Text>
    </View>
}
export default App;
.....................................................................................
		How to simplify the code using object destructuring
.....................................................................................
import { View, Text, StyleSheet } from "react-native"


// const App = () => {
//     // inline style 
//     return <View style={{backgroundColor:'pink'}}>
//         <Text>
//             Welcome to React Native
//         </Text>
//     </View>
// }

//external style object 
// const styles = StyleSheet.create({
//     backgroundColor: 'yellow'
// })

// const styles = StyleSheet.create({
//     container: {
//         backgroundColor: 'yellow'
//     },
//     text: {
//         fontSize: 100,
//         color: "red",
//     }

// })

const { container, text } = StyleSheet.create({
    container: {
        backgroundColor: 'yellow'
    },
    text: {
        fontSize: 100,
        color: "blue",
    }

})


const App = () => {
    // inline style 
    return <View style={container}>
        <Text style={text}>
            Welcome to React Native
        </Text>
    </View>
}
export default App;
.....................................................................................
				Style Composing
.....................................................................................

StyleSheet.compose:
Combines two styles such that style2 will override any styles in style1. If either style is falsy, the other one is returned without allocating an array, saving allocations and maintaining reference equality for PureComponent checks

import React from 'react';
import { StyleSheet, Text, View } from 'react-native';

const App = () => (
    <View style={container}>
        <Text style={text}>React Native</Text>
    </View>
);

const page = StyleSheet.create({
    //style-1
    container: {
        flex: 1,
        padding: 24,
        backgroundColor: 'yellow',
    },
    text: {
        fontSize: 30,
        color: '#000'
    },
});

const lists = StyleSheet.create({
    //style-2
    listContainer: {
        flex: 1,
        backgroundColor: 'green',
    },
    listItem: {
        fontStyle: 'italic',
        fontWeight: 'bold'
    },
});

//here style one will be overriden by style2
const container = StyleSheet.compose(page.container, lists.listContainer);
const text = StyleSheet.compose(page.text, lists.listItem);

export default App;
....................................................................................
We can write global styles for the entire app and we can override for any where in the app.

eg:
myexpo/globalstyles
    page.js
import { StyleSheet } from "react-native";

export const page = StyleSheet.create({
    //style-1
    container: {
        flex: 1,
        padding: 24,
        backgroundColor: 'yellow',
    },
    text: {
        fontSize: 30,
        color: '#000'
    },
});

App.js
import React from 'react';
import { StyleSheet, Text, View } from 'react-native';
import { page } from './globalstyles/page';

const App = () => (
    <View style={container}>
        <Text style={text}>React Native</Text>
    </View>
);

const lists = StyleSheet.create({
    //style-2
    listContainer: {
        flex: 1,
       // backgroundColor: 'green',
    },
    listItem: {
        fontStyle: 'italic',
        fontWeight: 'bold'
    },
});

//here style one will be overriden by style2
const container = StyleSheet.compose(page.container, lists.listContainer);
const text = StyleSheet.compose(page.text, lists.listItem);

export default App;
..................................................................................
			 Merging many styles into one
			Merging array of styles into one
..................................................................................

import React from "react";
import { StyleSheet, Text, View } from "react-native";

const App = () => (
  <View style={page.container}>
    <Text style={flattenStyle}>React Native</Text>
    <Text>Flatten Style</Text>
    <Text style={page.code}>
      {JSON.stringify(flattenStyle, null, 2)}
    </Text>
  </View>
);

const page = StyleSheet.create({
  container: {
    flex: 1,
    padding: 24,
    alignItems: "center"
  },
  text: {
    color: "#000",
    fontSize: 14,
    fontWeight: "bold"
  },
  code: {
    marginTop: 12,
    padding: 12,
    borderRadius: 8,
    color: "#666",
    backgroundColor: "#eaeaea"
  }
});

const typography = StyleSheet.create({
  header: {
    color: "#61dafb",
    fontSize: 30,
    marginBottom: 36
  }
});

const flattenStyle = StyleSheet.flatten([
  page.text,
  typography.header
]);

export default App;
...................................................................................
				compose vs flatten

1.compose will override from style1 properties to style2 properties.
  where as flatten also does same but ,it may take more styles objects(array of styles)
2.compose will not add any new properties,where flatten will add new properties from the style1 to style-N
.....................................................................................
				Style Sheet Properties
....................................................................................

1.absoluteFill :
A very common pattern is to create overlays with position absolute and zero positioning (position: 'absolute', left: 0, right: 0, top: 0, bottom: 0), so absoluteFill can be used for convenience and to reduce duplication of these repeated styles.
import React from 'react';
import { StyleSheet, Text, View } from 'react-native';

const App = () => (
    <View style={styles.container}>
        <View style={styles.box1}>
            <Text style={styles.text}>1</Text>
        </View>
        <View style={styles.box2}>
            <Text style={styles.text}>2</Text>
        </View>
        <View style={styles.box3}>
            <Text style={styles.text}>3</Text>
        </View>
    </View>
);

const styles = StyleSheet.create({
    container: {
        flex: 1
    },
    box1: {
        position: 'absolute',
        top: 40,
        left: 40,
        width: 100,
        height: 100,
        backgroundColor: 'red'
    },
    box2: {
        /**
         * ...StyleSheet.obsoluteFill to be merged with existing styles with default values.
         * ...spread operator is used here to merge with existing object properties
         */
        ...StyleSheet.absoluteFill,
        width: 100,
        height: 100,
        backgroundColor: 'blue'
    },
    box3: {
        position: 'absolute',
        top: 120,
        left: 120,
        width: 100,
        height: 100,
        backgroundColor: 'green'
    },
    text: {
        color: '#FFF',
        fontSize: 80
    }
});

export default App;

/////////////////////////////////////////////////////////////////////////////////////
                            hairlineWidth
import React from "react";
import { StyleSheet, Text, View } from "react-native";

const App = () => (
    <View style={styles.container}>
        <Text style={styles.row}>React</Text>
        <Text style={styles.row}>Native</Text>
    </View>
);

const styles = StyleSheet.create({
    container: {
        flex: 1,
        padding: 24
    },
    row: {
        padding: 4,
        borderBottomColor: "red",
        borderBottomWidth: StyleSheet.hairlineWidth
    }
});

export default App
.....................................................................................
			   Component Composition
.....................................................................................

import { React } from 'react'

import { View, Text, StyleSheet } from 'react-native'

const Greeter = () => <>
    <Text>Greeter!!!</Text>
</>

//Root Component
const App = () => <View style={styles.container}>
    <Greeter />
</View>



const styles = StyleSheet.create({
    container: {
        flex: 1,
        backgroundColor: '#fff',
        alignItems: 'center',
        justifyContent: 'center',
    },
});
export default App;
....................................................................................
rootfolder
  -greeter
     Greeter.jsx
import { Text } from "react-native"

export const Greeter = () => <>
    <Text>Greeter</Text>
</>

rootFolder
  App.js
import { React } from 'react'
import { View, Text, StyleSheet } from 'react-native'
import { Greeter } from './greeter/Greeter';

//Root Component
const App = () => <View style={styles.container}>
    <Greeter />
</View>


const styles = StyleSheet.create({
    container: {
        flex: 1,
        backgroundColor: '#fff',
        alignItems: 'center',
        justifyContent: 'center',
    },
});
export default App;
....................................................................................
				Props -Data
....................................................................................
import { React } from 'react'
import { View, Text, StyleSheet } from 'react-native'
import { Greeter } from './greeter/Greeter';
import { User } from './users/User';

//Root Component
const App = () => <View style={styles.container}>
    <Greeter />
    <Greeter message="Hello" name="Subramanian" />
    <Greeter message="Hello" name="Ram" />
    <User user={{ id: 1, name: 'Subramanian', city: 'Coimbatore' }} skills={
        ['Java','Javascript','Devops','Cloud']
    } />
</View>


const styles = StyleSheet.create({
    container: {
        flex: 1,
        backgroundColor: '#fff',
        alignItems: 'center',
        justifyContent: 'center',
    },
});
export default App;
import { Text,View } from "react-native"

export const User = props => <>
    <Text>Id : {props.user.id}</Text>
    <Text>Name :{props.user.name}</Text>
    <Text>City : {props.user.city}</Text>
    <View>
        {
            props.skills.map(skill => {
                return <Text>{skill}</Text>
            })
        }

    </View>
</>
//Default Props
User.defaultProps = {
    user: {
        userId: 0,
        name: 'React Native',
        city: 'Coimbatore',
        skills: []
    }
}
.....................................................................................
			  state,event handling
.....................................................................................
import { React, Component } from 'react'
import { View, Text, StyleSheet } from 'react-native'


//state 
export class Counter extends Component {
    state = {
        value: 10
    }
    render() {
        return <View>
            <Text>Counter App!!</Text>
            <Text>Value {this.state.value}</Text>
        </View>
    }
}

//Root Component
const App = () => <View style={styles.container}>
    <Counter />
</View>


const styles = StyleSheet.create({
    container: {
        flex: 1,
        backgroundColor: '#fff',
        alignItems: 'center',
        justifyContent: 'center',
    },
});
export default App;
.....................................................................................					Button Component

Button
A basic button component that should render nicely on any platform. Supports a minimal level of customization.

<Button
  onPress={onPressLearnMore}
  title="Learn More"
  color="#841584"
  accessibilityLabel="Learn more about this purple button"
/>

import { React, Component } from 'react'
import { View, Text, StyleSheet, Button } from 'react-native'


//state 
export class Counter extends Component {
    state = {
        value: 10
    }
    onIncrement = () => {
        this.setState((prevState) => {
            return { ...prevState, value: prevState.value + 1 }
        })
    }   

    render() {
        return <View>
            <Text>Counter App!!</Text>
            <Text>Value {this.state.value}</Text>
            <Button
                onPress={this.onIncrement}
                title="Increment"
                color="#841584"
                accessibilityLabel="Learn more about this purple button"
            />
        </View>
    }
}

//Root Component
const App = () => <View style={styles.container}>
    <Counter />
</View>


const styles = StyleSheet.create({
    container: {
        flex: 1,
        backgroundColor: '#fff',
        alignItems: 'center',
        justifyContent: 'center',
    },
});
export default App;
....................................................................................
			    Hooks
....................................................................................
What is Hooks?
  Hooks are a new addition in React 16.8. They let you use state and other React features without writing a class.
 Hook is  a plain js function.


Why hooks?

1. Code Resue
  if you to repeate biz logic of component , in class component is not possible
via hooks(functions) it is possible

2.Code reduction
  to eleminate lot of boiler plate code

Hook is just simple javascript function.
which may take arg or may not.
Which may or may not return something 	


every hook function starts with
  "use"+functionName ==>hook Syntax

eg:
"useState"
"useContext"
"useEffect"
"useAjax"
"useWebSocket"
"useLayout"
etc....
you can create your own hooks as well.


useState:
.........
const [state, setState] = useState(initialState);
Returns a stateful value, and a function to update it.

During the initial render, the returned state (state) is the same as the value passed as the first argument (initialState).

The setState function is used to update the state. It accepts a new state value and enqueues a re-render of the component.

Simple Hook:

Hook can be primtive,object ,array.

import { React, useState } from 'react'
import { View, Text, StyleSheet, Button } from 'react-native'


export const Counter = () => {
    const [value, setValue] = useState(200)

    const onIncrement = () => {
        setValue(previousValue => {
            return previousValue + 1
        })
    }
    return <View>
        <Text>Counter App!!</Text>
        <Text>Value {value}</Text>
        <Button
            onPress={onIncrement}
            title="Increment"
            color="#841584"
            accessibilityLabel="Learn more about this purple button"
        />
    </View>

}

//Root Component
const App = () => <View style={styles.container}>
    <Counter />
</View>


const styles = StyleSheet.create({
    container: {
        flex: 1,
        backgroundColor: '#fff',
        alignItems: 'center',
        justifyContent: 'center',
    },
});
export default App;
.....................................................................................
import { React, useState } from 'react'
import { View, Text, StyleSheet, Button } from 'react-native'


export const Counter = () => {
    const [value, setValue] = useState(200)
    const [like, setLike] = useState(100)
    const [counter, setCounter] = useState({ value: 10 })

    const onIncrement = () => {
        setValue(previousValue => {
            return previousValue + 1
        })
    }
    const onLike = () => {
        setLike(previousValue => {
            return previousValue + 1
        })
    }
    //object mutation
    const onCounter = () => {
        setCounter(oldState => {
            return { ...oldState, value: oldState.value + 1 }
        })
    }

    return <View>
        <Text>Counter Value {value} Like {like}</Text>
        <Text>Counter Object {counter.value}</Text>

        <Button
            onPress={onIncrement}
            title="Increment"
            color="#841584"
            accessibilityLabel="Learn more about this purple button"
        />
        <View style={{ marginTop: 10 }}>
            <Button
                onPress={onLike}
                title="Like"
                color="#841584"
                accessibilityLabel="Learn more about this purple button"
            />
        </View>
        <View style={{ marginTop: 10 }}>
            <Button
                onPress={onCounter}
                title="Counter Object"
                color="#841584"
                accessibilityLabel="Learn more about this purple button"
            />
        </View>
    </View>

}

//Root Component
const App = () => <View style={styles.container}>
    <Counter />
</View>


const styles = StyleSheet.create({
    container: {
        flex: 1,
        backgroundColor: '#fff',
        alignItems: 'center',
        justifyContent: 'center',
    },
});
export default App;
....................................................................................
			User Input- TextInput Component
....................................................................................

A foundational component for inputting text into the app via a keyboard. Props provide configurability for several features, such as auto-correction, auto-capitalization, placeholder text, and different keyboard types, such as a numeric keypad.

The most basic use case is to plop down a TextInput and subscribe to the onChangeText events to read the user input. There are also other events, such as onSubmitEditing and onFocus that can be subscribed to

import { React, useState } from 'react'
import { View, Text, StyleSheet, Button, TextInput, Alert } from 'react-native'

const UserInput = () => {
    //state variable to capture user intput
    const [text, setText] = useState('Greet')
    // const update = name => {
    //     setText(name)
    // }
    return <View>
        <Text style={styles.label}>Enter Your Name</Text>
        {/* inline listener */}
        <TextInput style={styles.input} value={text} onChangeText={name => {
            setText(name)
        }} />
        <Text style={styles.label}>Your Name is : {text}</Text>
        {/* Inline listner */}
        <Button title='Show Name' onPress={() => {
            Alert.alert(text)
        }} />
    </View>
}

//Root Component
const App = () => <View style={styles.container}>
    <UserInput />
</View>


const styles = StyleSheet.create({
    container: {
        flex: 1,
        backgroundColor: '#fff',
        alignItems: 'center',
        justifyContent: 'center',
    },
    label: {
        fontSize: 25,
        color: 'red'
    },
    input: {
        height: 40,
        width: 300,
        margin: 12,
        borderWidth: 1,
        padding: 10
    },
    listItem: {
        padding: 10,
        marginVertical: 10,
        backgroundColor: 'pink'
    }
});
export default App;
.....................................................................................
TextInput Properties:

1.defaultValue
2.editable
3.multiline
4.autofocus
5.maxlength
6.Place Holder

How to declare TextInput to Accept passwords:

secureTextEntry 
If true, the text input obscures the text entered so that sensitive text like passwords stay secure. The default value is false. Does not work with multiline={true}.
 <TextInput style={styles.input}
            placeholder="Password"
            placeholderTextColor="#9a73ef"
            returnKeyType='go'
            secureTextEntry
            autoCorrect={false}
        />
import { React, useState } from 'react'
import { View, Text, StyleSheet, Button, TextInput, Alert } from 'react-native'

const UserInput = () => {
    //state variable to capture user intput
    const [text, setText] = useState('Greet')
    // const update = name => {
    //     setText(name)
    // }
    return <View>
        <Text style={styles.label}>Enter Your Name</Text>
        {/* inline listener */}
        <TextInput multiline={true} style={styles.input} autoFocus={true} defaultValue={'default'} onChangeText={name => {
            setText(name)
        }} />
        <Text style={styles.label}>Enter Your Password</Text>
        {/* inline listener */}
        <TextInput style={styles.input}
            placeholder="Password"
            placeholderTextColor="#9a73ef"
            returnKeyType='go'
            secureTextEntry
            autoCorrect={false}
        />
        <Text style={styles.label}>Your Name is : {text}</Text>
        {/* Inline listner */}
        <Button title='Show Name' onPress={() => {
            Alert.alert(text)
        }} />
    </View>
}

//Root Component
const App = () => <View style={styles.container}>
    <UserInput />
</View>


const styles = StyleSheet.create({
    container: {
        flex: 1,
        backgroundColor: '#fff',
        alignItems: 'center',
        justifyContent: 'center',
    },
    label: {
        fontSize: 25,
        color: 'red'
    },
    input: {
        height: 40,
        width: 300,
        margin: 12,
        borderWidth: 1,
        padding: 10
    },
    listItem: {
        padding: 10,
        marginVertical: 10,
        backgroundColor: 'pink'
    }
});
export default App;
....................................................................................
				Design-Colors
...................................................................................

How to use colors?

 -color names; red blue; which is not mostly recommended.
 -color values ; #

Color Representation:

RGB
HSL
color int
color strings

https://reactnative.dev/docs/colors

Colors API
 React Native has several color APIs designed to allow you to take full advantage of your platform's design and user preferences.

PlatformColor 
  lets you reference the platform's color system.

PlatformColor(color1, [color2, ...colorN]);

 You can use the PlatformColor function to access native colors on the target platform by supplying the native color’s corresponding string value

If you pass more than one string value to the PlatformColor function, it will treat the first value as the default and the rest as fallback.

PlatformColor('bogusName', 'linkColor');

Supported colors
:
For a full list of the types of system colors supported.

Android:
 R.attr - ?attr prefix
 R.color - @android:color prefix

iOS (Objective-C and Swift notations):
UIColor Standard Colors
UIColor UI Element Colors


DynamicColorIOS 
   is iOS specific and allows you to specify which colors should be used in light or Dark Mode.
.....................................................................................
				Platform

Platform is Object , used to detect on which platform you are in, accordingly if you want to render some features like, colors.

Platform class offers static properties
constants
	Version,Release...
isPadiOS
isTV
isTesting
OS
Version

methods:
Platform.select(config:Object)

The config parameter is an object with the following keys:
android (any)
ios (any)
native (any)
default (any)

Platform.select({
 android: ?
 ios:?
})

select method how works?
 select internally applies if logic to select os

Platform.OS === 'platform' or a Platform.select()
.
import React from 'react';
import {
    Platform,
    PlatformColor,
    StyleSheet,
    Text,
    View
} from 'react-native';


const App = () => (
    <View style={styles.container}>
        <Text style={styles.label}>
            I am a special label color!
	
        </Text>
    </View>
);

const styles = StyleSheet.create({
    label: {
        padding: 16,
        ...Platform.select({
            ios: {
                color: PlatformColor('label'),
                backgroundColor:
                    PlatformColor('systemTealColor'),
            },
            android: {
                color: PlatformColor('?android:attr/textColor'),
                backgroundColor:
                    PlatformColor('@android:color/holo_blue_bright'),
            },
            default: { color: 'black' }
        })
    },
    container: {
        flex: 1,
        alignItems: 'center',
        justifyContent: 'center',
        ...Platform.select({
            ios: {
                color: PlatformColor('label'),
                backgroundColor:
                    PlatformColor('systemTealColor'),
            },
            android: {
                color: PlatformColor('?android:attr/textColor'),
                backgroundColor:
                    PlatformColor('@android:color/holo_orange_dark'),
            },
            default: { color: 'black' }
        })
    }
});

export default App;
..................................................................................
			Design - Height and Width
..................................................................................

Height and Width
 A component's height and width determine its size on the screen.

Fixed Dimensions
   The general way to set the dimensions of a component is by adding a fixed width and height to style. All dimensions in React Native are unitless, and represent density-independent pixels

import React from 'react';
import {
    View
} from 'react-native';

const FixedDimensionsBasics = () => {
    return (
        <View>
            <View style={{
                width: 50, height: 50, backgroundColor: 'powderblue'
            }} />
            <View style={{
                width: 100, height: 100, backgroundColor: 'skyblue'
            }} />
            <View style={{
                width: 150, height: 150, backgroundColor: 'steelblue'
            }} />
        </View>
    );
};

const App = () => <FixedDimensionsBasics />



export default App;

The problems in fixed width Dimensions:

1.if device size changes, which will not update the ui according to screen sizes.
.....................................................................................

Flex Dimensions / Flexable Deminisions

  Use flex in a component's style to have the component expand and shrink dynamically based on available space.

Layouts:
........
-Every UI, Design starts with box, Box model.
-Every Element/Widget/Component is a box.


Every Box has the following properties

1.width
2.height

measurements are specified using device px, in react native we dont tell units.

 width: 100px / 100% -html

The value of width  of an component , in general the "width of container"
The value of height of an component ,the component height.

space :

Space can be allocated of an component 

1.margin
   The space allocated outside component
2.padding
  The space allocated inside component

Faces of widget:
................

Clock wise order
 Top---Right---bottom--left

space allocation based on sides

leftMargin:10
rightMargin:10
topMargin:10
bottomMargin:10

padding : left,right,top,bottom

Allocate 10px padding and margin equally in all sides

padding : 10
margin :10

Layout types in css/Web:

1.box layout - height,width,float,alignments
2.grid layout
3.flex box

Flex Box:

What is flex box / flex?

The flex box is specification introduced in css  to build responsive web application alternate to grid layout.

flexbox is one dimensional layout model, where as gird layout is two dimensional layout.

Any layout is box based design

layout is rendered as row-column coimbation : two dimensional layout
     "Grid"

layout is rendered either row or column direction ; one dimensional layout 
     "Flex"
Flex box basics:

Axes of Flex:
 There are two types of axes

1.Main axis
2.Cross axis

How to activate the flex layout?

 Flex layout is already activated in side every react native elements.

we can override flex property
eg:

flex : 1 

flex will define how your items are going to “fill” over the available space along your main axis. Space will be divided according to each element's flex property.

The main axis is defined by "flex-direction" which has four values

 row
 row-reverse
 column
 column-reverse

 flexDirection: row | column | row-reverse | column-reverse

https://medium.com/wix-engineering/the-full-react-native-layout-cheat-sheet-a4147802405c
https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Flexible_Box_Layout/Basic_Concepts_of_Flexbox

import React, { Component } from 'react';
import { View, Text } from 'react-native';

const App = () => {
    // Try setting `flexDirection` to 'column'/'column-reverse'/'row'/'row-reverse'
    return <View style={styles.container}>
        <Text style={styles.headerStyle}>flexDirection: 'row-reverse'</Text>
        {/* <View style={[{ flexDirection: 'row' }, styles.elementsContainer]}> */}
        {/* <View style={[{ flexDirection: 'row-reverse' }, styles.elementsContainer]}> */}
        {/* <View style={[{ flexDirection: 'column-reverse' }, styles.elementsContainer]}> */}
        <View style={[{ flexDirection: 'row-reverse',justifyContent:'space-around' }, styles.elementsContainer]}>
            <View style={{ width: 50, height: 50, backgroundColor: '#EE2C38' }} />
            <View style={{ width: 50, height: 50, backgroundColor: '#FAA030' }} />
            <View style={{ width: 50, height: 50, backgroundColor: '#32B76C' }} />
        </View>
    </View>
}

const styles = {
    container: {
        marginTop: 48,
        backgroundColor:'pink',
        flex: 1
    },
    headerStyle: {
        fontSize: 24,
        textAlign: 'center',
        fontWeight: '100',
        marginBottom: 24
    },
    elementsContainer: {
        flex: 1,
        paddingLeft: 10,
        paddingTop:  10,
        backgroundColor: '#ecf5fd',
        marginLeft: 24,
        marginRight: 24,
        marginBottom: 24
    }
}

export default App;
.....................................................................................
			 Mobile App Layouts
.....................................................................................

Mobile Apps are mostly based on layoutting model is called "ListView"

View Types:

1.View 
   Container View which contains other views and components
   It does not Scrollable
2.ScrollView
3.FlatList
...................................................................................
		         ScrollView

import React, { Component } from 'react';
import { View, Text, ScrollView } from 'react-native';

const App = () => {
    // Try setting `flexDirection` to 'column'/'column-reverse'/'row'/'row-reverse'
    return <View style={styles.container}>
        <Text style={styles.headerStyle}>ScrollView</Text>
       
        <ScrollView style={[{ flexDirection: 'column' }, styles.elementsContainer]}>
             <Text style={{color:'red', fontWeight:'bold',fontFamily:'Calibri'}}>
             Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt
                    ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation
                    ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in
                    reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur
                    sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id
                    est laborum.

                    Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt
                    ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation
                    ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in
                    reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur
                    sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id
                    est laborum.
                    Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt
                    ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation
                    ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in
                    reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur
                    sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id
                    est laborum.  Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt
                    ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation
                    ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in
                    reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur
                    sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id
                    est laborum.  Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt
                    ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation
                    ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in
                    reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur
                    sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id
                    est laborum.  Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt
                    ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation
                    ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in
                    reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur
                    sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id
                    est laborum.  Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt
                    ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation
                    ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in
                    reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur
                    sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id
                    est laborum.  Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt
                    ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation
                    ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in
                    reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur
                    sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id
                    est laborum.    
             </Text>
             <Text style={{color:'blue'}}>
             Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt
                    ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation
                    ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in
                    reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur
                    sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id
                    est laborum.

                    Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt
                    ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation
                    ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in
                    reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur
                    sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id
                    est laborum.
                    Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt
                    ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation
                    ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in
                    reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur
                    sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id
                    est laborum.  Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt
                    ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation
                    ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in
                    reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur
                    sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id
                    est laborum.  Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt
                    ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation
                    ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in
                    reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur
                    sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id
                    est laborum.  Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt
                    ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation
                    ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in
                    reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur
                    sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id
                    est laborum.  Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt
                    ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation
                    ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in
                    reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur
                    sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id
                    est laborum.  Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt
                    ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation
                    ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in
                    reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur
                    sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id
                    est laborum.    
             </Text>
        </ScrollView>
    </View>
}

const styles = {
    container: {
        marginTop: 48,
        backgroundColor:'pink',
        flex: 1
    },
    headerStyle: {
        fontSize: 24,
        textAlign: 'center',
        fontWeight: '100',
        marginBottom: 24
    },
    elementsContainer: {
        flex: 1,
        paddingLeft: 10,
        paddingTop:  10,
        backgroundColor: '#ecf5fd',
        marginLeft: 24,
        marginRight: 24,
        marginBottom: 24
    }
}

export default App;
.....................................................................................
				FlatList and SectionList
.....................................................................................


FlatList: 

To render list along with scrollbar.

<ScrollView> vs <FlatList> - which one to use?

ScrollView renders all its react child components at once, but this has a performance downside.

Imagine you have a very long list of items you want to display, maybe several screens worth of content. Creating JS components and native views for everything all at once, much of which may not even be shown, will contribute to slow rendering and increased memory usage.

This is where FlatList comes into play. FlatList renders items lazily, when they are about to appear, and removes items that scroll way off screen to save memory and processing time.

FlatList is also handy if you want to render separators between your items, multiple columns, infinite scroll loading, or any number of other features it supports out of the box.

Fully cross-platform.
Optional horizontal mode.
Configurable viewability callbacks.
Header support.
Footer support.
Separator support.
Pull to Refresh.
Scroll loading.
ScrollToIndex support.
Multiple column support.

Syntax:
const users = [{id:1,name:'a'}]

<FlatList 
         keyExtractor={(item)=>item.id} 
         data={users}
         renderItem={({item}) => (
            <Text style={styles.item}>{item.name}</Text>
)} />

keyExtractor:
	which is eq key prop in react.
(item: object, index: number) => string;

Used to extract a unique key for a given item at the specified index. Key is used for caching and as the react key to track item re-ordering. The default extractor checks item.key, then item.id, and then falls back to using the index, like React does.

eg:  
  users.map(user=>{
     return <li key={user.id}>
	
   </li>
  })

data:
  which binds array as data source

renderItem : {renderItemFunction}

renderItemFunction(item:Object,index:number,separators:Object){
	
}

  <FlatList
            data={messageList}
            renderItem={
                (obj) => {
                    console.log(obj)
                    return <Text>something</Text>
                }
            }
        />

output:
Object {
  "index": 0,
  "item": Object {
    "id": 1,
    "message": "hello",
  },
  "separators": Object {
    "highlight": [Function highlight],
    "unhighlight": [Function unhighlight],
    "updateProps": [Function updateProps],
  },
}
renderItem function returns one single object which has three keys

1.index
2.item
3.separators

 <FlatList
            data={messageList}
            renderItem={
                (obj) => {
                    console.log(obj)
                    return <Text>{obj.item.message}</Text>
                }
            }
        />
        <FlatList
            data={messageList}
            renderItem={
                ({ item, index, separators }) => {
                    console.log(item, index, separators)
                    return <Text>{item.message}</Text>
                }
            }
        />
        <FlatList
            data={messageList}
            renderItem={
                ({ item, index, separators }) => {
                    console.log(item, index, separators)
                    const { message } = item
                    return <Text>{message}</Text>
                }
            }
        />
....................................................................................
			   import React, { Component } from 'react';
import { View, Text, ScrollView, FlatList } from 'react-native';


const messageList = [{
    id: 1,
    message: 'hello'
},
{
    id: 2,
    message: 'hai'
},
{
    id: 3,
    message: 'welcome'
},
{
    id: 4,
    message: 'greet'
}

]

const App = () => {
    // Try setting `flexDirection` to 'column'/'column-reverse'/'row'/'row-reverse'
    return <View style={styles.container}>
        <Text style={styles.headerStyle}>ListView</Text>
        {/* <FlatList
            data={messageList}
            renderItem={
                (obj) => {
                    console.log(obj)
                    return <Text>something</Text>
                }
            }
        /> */}
        <FlatList
            data={messageList}
            renderItem={
                (obj) => {
                    console.log(obj)
                    return <Text>{obj.item.message}</Text>
                }
            }
        />
        <FlatList
            data={messageList}
            renderItem={
                ({ item, index, separators }) => {
                    console.log(item, index, separators)
                    return <Text>{item.message}</Text>
                }
            }
        />
        <FlatList
            keyExtractor={(message) => {
                console.log('keyExtractor', message)
                return message.id
            }}
            data={messageList}
            renderItem={
                ({ item, index, separators }) => {
                    console.log(item, index, separators)
                    const { message } = item
                    return <Text>{message}</Text>
                }
            }
        />
    </View>
}

const styles = {
    container: {
        marginTop: 48,
        backgroundColor: 'pink',
        flex: 1
    },
    headerStyle: {
        fontSize: 24,
        fontWeight: 'bolder',
        textAlign: 'center',
        marginBottom: 24
    },
    elementsContainer: {
        flex: 1,
        paddingLeft: 10,
        paddingTop: 10,
        backgroundColor: '#ecf5fd',
        marginLeft: 24,
        marginRight: 24,
        marginBottom: 24
    }
}

export default App;
.....................................................................................
			WebService/Back End Integrations
.....................................................................................

ReactNative does not have any opinion which lib for talking to backend services.

Most Popular libs for react echo system.

1.fetch api
2.axios

When to make api calls in Ui apps.

1.during inital render
  when you lanuch app, you need to load data ,that time we need to talk to api
2.after user interaction
  when you submit a form,you press some item, when you press a menu...

1.during inital render
  when you lanuch app, you need to load data ,that time we need to talk to api

Component Life Cycles:
......................

Every Component has three life cycle phase.
Each Phase has different apis

Phases
1.mount
   This phase is a inital phase

constructor - not used widely even in class components
2.render :
   render is method used to prepare inital "virtual object tree"
after render completes,
  React engine will insert virtual object tree into platforms(browser / mobile)

3.componentDidMount is called
   Inside componentDidMount we are going to perform most expensive operations
eg:
  ajax/api calls
  Timers
  Websocket calls

2.update
3.unmount

import React, { Component, useEffect, useState } from 'react';
import { View, Text, FlatList, StatusBar, StyleSheet, Alert } from 'react-native';


//Post component
export const Post = props => {

    const [posts, setPosts] = useState([])

    //componentDid == useEffect 
    useEffect(() => {
        const url = 'https://jsonplaceholder.typicode.com/posts'
        fetch(url)
            .then(res => res.json())
            .then(posts => {
                setTimeout(() => {
                    setPosts(prvPosts => {
                        return prvPosts.concat(posts)
                    })
                }, 5000)

            })
            .catch(err => {
                console.log(err)
            })
    }, [])

    console.log('Post Component is rendering for now')

    const onPressItem = item => {
        console.log(item)
        Alert.alert(JSON.stringify(item))
    }

    return <View>
        <Text style={styles.headerStyle}>POST Fetching</Text>
        <FlatList
            keyExtractor={(post) => {
                return post.id
            }}
            data={posts}
            renderItem={
                ({ item }) => {
                    const { title } = item
                    return <View style={styles.item}>
                        <Text onPress={() => { onPressItem(item) }} style={styles.title}>{title}</Text>
                    </View>
                }
            }
        />
    </View>
}



const App = () => {
    return <View style={styles.container}>
        <Post />
    </View>
}

const styles = StyleSheet.create({
    container: {
        flex: 1,
        marginTop: StatusBar.currentHeight || 0,
    },
    item: {
        backgroundColor: '#f9c2ff',
        padding: 20,
        marginVertical: 8,
        marginHorizontal: 16,
    },
    title: {
        fontSize: 32,
    },
});
export default App;
.....................................................................................
				Conditional rendering
.....................................................................................

Since ajax calls are async, we cant predicat when the data is available. mean time user has no idea whether data is coming or not. 
We need to show some spinner.
			
conditional rendering means, based on if ...else or tenary operator, we can render component.


import React, { useEffect, useState } from 'react';
import { View, Text, FlatList, StatusBar, StyleSheet, ActivityIndicator, Alert } from 'react-native';


export const Post = props => {

    const [posts, setPosts] = useState({
        error: null, // if any ajax error
        isLoaded: false, //Progress bar enabler
        items: []  // data to be filed
    })

    //componentDid == useEffect 
    useEffect(() => {
        const url = 'https://jsonplaceholder.typicode.com/posts'
        fetch(url)
            .then(res => res.json())
            .then(posts => {
                setTimeout(() => {
                    setPosts(prvState => {
                        return { ...prvState, isLoaded: true, items: posts }
                    });
                }, 10000)

            }, (error) => {
                setPosts({
                    isLoaded: true,
                    error
                });
            })

    }, [])

    //console.log('posts ',posts)

    const onPressItem = item => {
        console.log(item)
        Alert.alert(JSON.stringify(item))
    }
    //use object destructuring
    const { error, items, isLoaded } = posts;

    if (error) {
        //render error component
        return <View style={styles.error}> Error: {error.message}</View>;
    } else if (!isLoaded) {
        return <View style={styles.loader}>
            <ActivityIndicator size="large" color="#00ff00" />
        </View>;
    } else {
        return <View styles={styles.container}>
            <FlatList
                keyExtractor={(post) => {
                    return post.id
                }}
                data={items}
                renderItem={
                    ({ item }) => {
                        const { title } = item
                        return <View style={styles.item}>
                            <Text onPress={() => { onPressItem(item) }} style={styles.title}>{title}</Text>
                        </View>
                    }
                }
            />
        </View>
    }

}



const App = () => {
    return <View style={styles.container}>
        <Post />
    </View>
}

const styles = StyleSheet.create({
    container: {
        flex: 1,
        backgroundColor: '#fff',
        alignItems: 'center',
        justifyContent: 'center',
    },
    error: {
        flex: 1,
        backgroundColor: '#fff',
        alignItems: 'center',
        justifyContent: 'center',
    },
    loader: {
        flex: 1,
        backgroundColor: '#fff',
        alignItems: 'center',
        justifyContent: 'center',
    },
    item: {
        flex: 1,
        marginHorizontal: 10,
        marginTop: 25,
        padding: 30,
        backgroundColor: 'pink',
        fontSize: 24
    }
});

export default App;
.....................................................................................
			Presentational and Container Components
.....................................................................................

Presentational Components will not have any biz logic and state , only UI
Container Components will have state and biz logic, not much UI.


import React, { useEffect, useState } from 'react';
import { View, Text, FlatList, StatusBar, StyleSheet, ActivityIndicator, Alert } from 'react-native';

//Presental Components 
//Error 
export const Error = props => {
    const { message } = props
    return <View style={styles.error}> Error: {message}</View>;
}
export const Spinner = props => {
    return <View style={styles.loader}>
        <ActivityIndicator size="large" color="#00ff00" />
    </View>;
}
export const PostListItem = props => {
    const { posts, onPressItem } = props
    return <View styles={styles.container}>
        <FlatList
            keyExtractor={(post) => {
                return post.id
            }}
            data={posts}
            renderItem={
                ({ item }) => {
                    const { title } = item
                    return <View style={styles.item}>
                        <Text onPress={() => { onPressItem(item) }} style={styles.title}>{title}</Text>
                    </View>
                }
            }
        />
    </View>
}

//Container
export const Post = props => {

    const [posts, setPosts] = useState({
        error: null, // if any ajax error
        isLoaded: false, //Progress bar enabler
        items: []  // data to be filed
    })

    //componentDid == useEffect 
    useEffect(() => {
        const url = 'https://jsonplaceholder.typicode.com/posts'
        fetch(url)
            .then(res => res.json())
            .then(posts => {
                setTimeout(() => {
                    setPosts(prvState => {
                        return { ...prvState, isLoaded: true, items: posts }
                    });
                }, 10000)

            }, (error) => {
                setPosts({
                    isLoaded: true,
                    error
                });
            })

    }, [])

    //console.log('posts ',posts)

    const onPressItem = item => {
        console.log(item)
        Alert.alert(JSON.stringify(item))
    }
    //use object destructuring
    const { error, items, isLoaded } = posts;
    if (error) {
        return <Error message={error.message} />
    } else if (!isLoaded) {
        return <Spinner />
    } else {
        return <PostListItem onPressItem={onPressItem} posts={items} />
    }


}



const App = () => {
    return <View style={styles.container}>
        <Post />
    </View>
}

const styles = StyleSheet.create({
    container: {
        flex: 1,
        backgroundColor: '#fff',
        alignItems: 'center',
        justifyContent: 'center',
    },
    error: {
        flex: 1,
        backgroundColor: '#fff',
        alignItems: 'center',
        justifyContent: 'center',
    },
    loader: {
        flex: 1,
        backgroundColor: '#fff',
        alignItems: 'center',
        justifyContent: 'center',
    },
    item: {
        flex: 1,
        marginHorizontal: 10,
        marginTop: 25,
        padding: 30,
        backgroundColor: 'pink',
        fontSize: 24
    }
});

export default App;
...................................................................................
				Handling Touch Features in Mobile:
.....................................................................................


Handling Touch Features in Mobile:
...................................
Users interact with mobile apps mainly through touch. They can use a combination of gestures, such as tapping on a button, scrolling a list, or zooming on a map. React Native provides components to handle all sorts of common gestures, as well as a comprehensive gesture responder system to allow for more advanced gesture recognition, but the one component you will most likely be interested in is the basic Button.


Touchable Components:
.....................

If the basic button doesn't look right for your app, you can build your own button using any of the "Touchable" components provided by React Native. The "Touchable" components provide the capability to capture tapping gestures, and can display feedback when a gesture is recognized. These components do not provide any default styling,
import React, { useEffect, useState } from 'react';
import { View, TouchableHighlight,TouchableOpacity, Text, FlatList, StatusBar, StyleSheet, ActivityIndicator, Alert } from 'react-native';

//Presental Components 
//Error 
export const Error = props => {
    const { message } = props
    return <View style={styles.error}> Error: {message}</View>;
}
export const Spinner = props => {
    return <View style={styles.loader}>
        <ActivityIndicator size="large" color="#00ff00" />
    </View>;
}
export const PostListItem = props => {
    const { posts, onPressItem } = props
    return <View styles={styles.container}>
        <FlatList
            keyExtractor={(post) => {
                return post.id
            }}
            data={posts}
            renderItem={
                ({ item }) => {
                    const { title } = item
                    return <View style={styles.item}>
                        {/* <TouchableHighlight activeOpacity={0.6} underlayColor="#fff" onPress={() => { onPressItem(item) }}>
                            <Text>{title}</Text>
                        </TouchableHighlight> */}
                           <TouchableOpacity activeOpacity={0.6} underlayColor="#fff" onPress={() => { onPressItem(item) }}>
                            <Text>{title}</Text>
                        </TouchableOpacity>
                    </View>
                }
            }
        />
    </View>
}

//Container
export const Post = props => {

    const [posts, setPosts] = useState({
        error: null, // if any ajax error
        isLoaded: false, //Progress bar enabler
        items: []  // data to be filed
    })

    //componentDid == useEffect 
    useEffect(() => {
        const url = 'https://jsonplaceholder.typicode.com/posts'
        fetch(url)
            .then(res => res.json())
            .then(posts => {
                setTimeout(() => {
                    setPosts(prvState => {
                        return { ...prvState, isLoaded: true, items: posts }
                    });
                }, 10000)

            }, (error) => {
                setPosts({
                    isLoaded: true,
                    error
                });
            })

    }, [])

    //console.log('posts ',posts)

    const onPressItem = item => {
        console.log(item)
        Alert.alert(JSON.stringify(item))
    }
    //use object destructuring
    const { error, items, isLoaded } = posts;
    if (error) {
        return <Error message={error.message} />
    } else if (!isLoaded) {
        return <Spinner />
    } else {
        return <PostListItem onPressItem={onPressItem} posts={items} />
    }


}



const App = () => {
    return <View style={styles.container}>
        <Post />
    </View>
}

const styles = StyleSheet.create({
    container: {
        flex: 1,
        backgroundColor: '#fff',
        alignItems: 'center',
        justifyContent: 'center',
    },
    error: {
        flex: 1,
        backgroundColor: '#fff',
        alignItems: 'center',
        justifyContent: 'center',
    },
    loader: {
        flex: 1,
        backgroundColor: '#fff',
        alignItems: 'center',
        justifyContent: 'center',
    },
    item: {
        flex: 1,
        marginHorizontal: 10,
        marginTop: 25,
        padding: 30,
        backgroundColor: 'pink',
        fontSize: 24
    }
});

export default App;
.....................................................................................
				Status Bar
....................................................................................
StatusBar
Component to control the app's status bar. The status bar is the zone, typically at the top of the screen, that displays the current time, Wi-Fi and cellular network information, battery level and/or other status icons.

 <StatusBar
        animated={true}
        backgroundColor="#61dafb"
        barStyle={statusBarStyle}
        showHideTransition={statusBarTransition}
        hidden={hidden} />

import React, { useState } from 'react';
import { Button, Platform, SafeAreaView, StatusBar, StyleSheet, Text, View } from 'react-native';

const STYLES = ['default', 'dark-content', 'light-content'];
const TRANSITIONS = ['fade', 'slide', 'none'];

const App = () => {
  const [hidden, setHidden] = useState(false);
  const [statusBarStyle, setStatusBarStyle] = useState(STYLES[2]);
  const [statusBarTransition, setStatusBarTransition] = useState(TRANSITIONS[1]);

  const changeStatusBarVisibility = () => setHidden(!hidden);

  const changeStatusBarStyle = () => {
    const styleId = STYLES.indexOf(statusBarStyle) + 1;
    if (styleId === STYLES.length) {
      setStatusBarStyle(STYLES[0]);
    } else {
      setStatusBarStyle(STYLES[styleId]);
    }
  };

  const changeStatusBarTransition = () => {
    const transition = TRANSITIONS.indexOf(statusBarTransition) + 1;
    if (transition === TRANSITIONS.length) {
      setStatusBarTransition(TRANSITIONS[0]);
    } else {
      setStatusBarTransition(TRANSITIONS[transition]);
    }
  };

  return (
    <SafeAreaView style={styles.container}>
      <StatusBar
        animated={true}
        backgroundColor="#61dafb"
        barStyle={statusBarStyle}
        showHideTransition={statusBarTransition}
        hidden={hidden} />
      <Text style={styles.textStyle}>
        StatusBar Visibility:{'\n'}
        {hidden ? 'Hidden' : 'Visible'}
      </Text>
      <Text style={styles.textStyle}>
        StatusBar Style:{'\n'}
        {statusBarStyle}
      </Text>
      {Platform.OS === 'ios' ? (
        <Text style={styles.textStyle}>
          StatusBar Transition:{'\n'}
          {statusBarTransition}
        </Text>
      ) : null}
      <View style={styles.buttonsContainer}>
        <Button
          title="Toggle StatusBar"
          onPress={changeStatusBarVisibility} />
        <Button
          title="Change StatusBar Style"
          onPress={changeStatusBarStyle} />
        {Platform.OS === 'ios' ? (
          <Button
            title="Change StatusBar Transition"
            onPress={changeStatusBarTransition} />
        ) : null}
      </View>
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    backgroundColor: '#ECF0F1'
  },
  buttonsContainer: {
    padding: 10
  },
  textStyle: {
    textAlign: 'center',
    marginBottom: 8
  }
});

export default App;
.....................................................................................
			 Switch Component - Boolean
.....................................................................................

Todo App with Switch Component to make todo , done or  not 
import React from 'react';
import { View, Button, Text, ScrollView, StyleSheet, StatusBar, Switch } from 'react-native'

let id = 0

const styles = StyleSheet.create({
    todoContainer: {
        marginTop: 50,
        flexDirection: 'row',
        alignItems: 'center',
    },
    appContainer: {
        paddingTop: 10,
        marginTop: 20,

    },
    // Let container (ScrollView (todo container) & View (app container)) fills up all possible space
    fill: {
        flex: 1,
    }
})

export const Todo = props => (
    <View style={styles.todoContainer}>
        <Switch value={props.todo.checked} onValueChange={props.onToggle} />
        <Button onPress={props.onDelete} title="delete" />
        <Text>{props.todo.text}</Text>
    </View>
)
class App extends React.Component {
    state = {
        todos: [],
    }
    addTodo() {
        id++
        const text = `TODO number ${id}`
        this.setState({
            todos: [
                ...this.state.todos,
                { id: id, text: text, checked: false },
            ],
        })
    }

    removeTodo(id) {
        this.setState({
            todos: this.state.todos.filter(todo => todo.id !== id)
        })
    }

    toggleTodo(id) {
        this.setState({
            todos: this.state.todos.map(todo => {
                if (todo.id !== id) return todo
                return {
                    id: todo.id,
                    text: todo.text,
                    checked: !todo.checked,
                }
            })
        })
    }

    render() {
        return (
            <View style={[styles.appContainer, styles.fill]}>
                <StatusBar
                    animated={true}
                    backgroundColor="#61dafb"
                    barStyle={"default"}
                    showHideTransition={"fade"}
                    hidden={false} />
                <Text>Todo count: {this.state.todos.length}</Text>
                <Text>Unchecked todo count: {this.state.todos.filter(todo => !todo.checked).length}</Text>
                <Button onPress={() => this.addTodo()} title="Add TODO" />
                <ScrollView style={styles.fill}>
                    {this.state.todos.map(todo => (
                        <Todo
                            onToggle={() => this.toggleTodo(todo.id)}
                            onDelete={() => this.removeTodo(todo.id)}
                            todo={todo}
                        />
                    ))}
                </ScrollView>
            </View>
        )
    }
}

export default App;
.....................................................................................
			    Images
.....................................................................................
A React component for displaying different types of images, including network images, static resources, temporary local images, and images from local disk, such as the camera roll.


import React from 'react';
import { View, Image, StyleSheet } from 'react-native';

const styles = StyleSheet.create({
    container: {
        paddingTop: 50,
    },
    tinyLogo: {
        width: 50,
        height: 50,
    },
    logo: {
        width: 66,
        height: 58,
    },
});

const DisplayAnImage = () => {
    return (
        <View style={styles.container}>
            <Image
                style={styles.tinyLogo}
                source={require('./assets/favicon.png')}
            />
            <Image
                style={styles.tinyLogo}
                source={{
                    uri: 'https://reactnative.dev/img/tiny_logo.png',
                }}
            />
            <Image
                style={styles.logo}
                source={{
                    uri: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADMAAAAzCAYAAAA6oTAqAAAAEXRFWHRTb2Z0d2FyZQBwbmdjcnVzaEB1SfMAAABQSURBVGje7dSxCQBACARB+2/ab8BEeQNhFi6WSYzYLYudDQYGBgYGBgYGBgYGBgYGBgZmcvDqYGBgmhivGQYGBgYGBgYGBgYGBgYGBgbmQw+P/eMrC5UTVAAAAABJRU5ErkJggg==',
                }}
            />
        </View>
    );
}

const App = () => {
    return <DisplayAnImage />
}

export default App;
.....................................................................................
				ImageBackground

A common feature request from developers familiar with the web is background-image. To handle this use case, you can use the <ImageBackground> component, which has the same props as <Image>, and add whatever children to it you would like to layer on top of it.

import React from "react";
import { ImageBackground, StyleSheet, Text, View } from "react-native";

const image = { uri: "https://reactjs.org/logo-og.png" };

const App = () => (
  <View style={styles.container}>
    <ImageBackground source={image} resizeMode="cover" style={styles.image}>
      <Text style={styles.text}>Inside</Text>
    </ImageBackground>
  </View>
);

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  image: {
    flex: 1,
    justifyContent: "center"
  },
  text: {
    color: "white",
    fontSize: 42,
    lineHeight: 84,
    fontWeight: "bold",
    textAlign: "center",
    backgroundColor: "#000000c0"
  }
});

export default App;
...................................................................................
				  Modal		
The Modal component is a basic way to present content above an enclosing view.
...................................................................................
import React, { useState } from "react";
import { Alert, Modal, StyleSheet, Text, Pressable, View } from "react-native";

const App = () => {
    const [modalVisible, setModalVisible] = useState(false);
    return (
        <View style={styles.centeredView}>
            <Modal
                animationType="slide"
                transparent={true}
                visible={modalVisible}
                onRequestClose={() => {
                    Alert.alert("Modal has been closed.");
                    setModalVisible(!modalVisible);
                }}
            >
                <View style={styles.centeredView}>
                    <View style={styles.modalView}>
                        <Text style={styles.modalText}>Hello World!</Text>
                        <Pressable
                            style={[styles.button, styles.buttonClose]}
                            onPress={() => setModalVisible(!modalVisible)}
                        >
                            <Text style={styles.textStyle}>Hide Modal</Text>
                        </Pressable>
                    </View>
                </View>
            </Modal>
            <Pressable
                style={[styles.button, styles.buttonOpen]}
                onPress={() => setModalVisible(true)}
            >
                <Text style={styles.textStyle}>Show Modal</Text>
            </Pressable>
        </View>
    );
};

const styles = StyleSheet.create({
    centeredView: {
        flex: 1,
        justifyContent: "center",
        alignItems: "center",
        marginTop: 22
    },
    modalView: {
        margin: 20,
        backgroundColor: "white",
        borderRadius: 20,
        padding: 35,
        alignItems: "center",
        shadowColor: "#000",
        shadowOffset: {
            width: 0,
            height: 2
        },
        shadowOpacity: 0.25,
        shadowRadius: 4,
        elevation: 5
    },
    button: {
        borderRadius: 20,
        padding: 10,
        elevation: 2
    },
    buttonOpen: {
        backgroundColor: "#F194FF",
    },
    buttonClose: {
        backgroundColor: "#2196F3",
    },
    textStyle: {
        color: "white",
        fontWeight: "bold",
        textAlign: "center"
    },
    modalText: {
        marginBottom: 15,
        textAlign: "center"
    }
});

export default App;
..................................................................................
				Navigation
.................................................................................

How navigation works?

In a web browser, you can link to different pages using an anchor (<a>) tag. When the user clicks on a link, the URL is pushed to the browser history stack.

 When the user presses the back button, the browser pops the item from the top of the history stack, so the active page is now the previously visited page.

React Native doesn't have a built-in idea of a global history stack like a web browser does -- this is where React Navigation enters the story.

React Navigation's stack navigator provides a way for your app to transition between screens and manage navigation history.

If your app uses only one stack navigator then it is conceptually similar to how a web browser handles navigation state - your app pushes and pops items from the navigation stack as users interact with it, and this results in the user seeing different screens. 

A key difference between how this works in a web browser and in React Navigation is that React Navigation's stack navigator provides the gestures and animations that you would expect on Android and iOS when navigating between routes in the stack.

How to start react navigation?

Core lib:
 @react-navigation/native

Types of navigation:
1.screen to screen - stack navigation -  @react-navigation/stack
2.Tab - tab based navivation.  @react-navigation/bottom-tabs
3.Drawer -Drawer navigation.   @react-navigation/drawer

Incase of your project is expo based, we need to install peer dependencies as well

1.managed work flow
   expo install react-native-screens react-native-safe-area-context
2.bare work flow
  npm install react-native-screens react-native-safe-area-context


Stack Based Navigation:
.......................
npm install @react-navigation/native @react-navigation/native-stack
expo install react-native-screens react-native-safe-area-context
...................................................................................
		Component as Prop
....................................................................................
  <Header/> header has no childern
  <Header> header can have childern
	<Logo/>
  </Header>
import { StatusBar } from 'expo-status-bar';
import { StyleSheet, Text, View, Image } from 'react-native';

export const Logo = props => {
  return <Image
    style={styles.tinyLogo}
    source={require('./assets/favicon.png')}
  />
}

export const Header = props => {
  return <View>
    <Text>{props.title}</Text>
    <View>
      {props.children}
    </View>
  </View>
}

export default function App() {
  return (
    <View style={styles.container}>
      <Header title="React Native!!!">
        {/* Component as prop */}
        <Logo />
      </Header >
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#fff',
    alignItems: 'center',
    justifyContent: 'center',
  },
  tinyLogo: {
    width: 50,
    height: 50,
  }
});
.....................................................................................
				App Arch with Navigation

<App>
  <NavigationContainer>

  </NavigationContainer>
</App>

Navigation Objects:
...................
1.NavigationContainer

import { NavigationContainer } from '@react-navigation/native';
import { StatusBar } from 'expo-status-bar';
import { StyleSheet, Text, View, Image } from 'react-native';

export const Home = props => {
    return <View>
        <Text>Home</Text>
    </View>
}


const App = () => {
    return <View style={styles.container}>
        <NavigationContainer>
            {/* Here You have render Menu */}
            <Home/>
        </NavigationContainer>
    </View>
}

const styles = StyleSheet.create({
    container: {
        flex: 1,
        backgroundColor: '#fff',
        alignItems: 'center',
        justifyContent: 'center',
    }
});
export default App;
....................................................................................

import { NavigationContainer } from '@react-navigation/native';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { StyleSheet, Text, View } from 'react-native';

export const HomeScreen = props => {
    return <View style={styles.container}>
        <Text>Home Screen</Text>
    </View>
}

//create Object By calling createNativeStackNavigator function 
const Stack = createNativeStackNavigator()
console.log(Stack)

const App = () => {
    return <NavigationContainer>
        <Stack.Navigator>
            <Stack.Screen name="Home" component={HomeScreen} />
        </Stack.Navigator>
    </NavigationContainer>
}

const styles = StyleSheet.create({
    container: {
        flex: 1,
        backgroundColor: '#fff',
        alignItems: 'center',
        justifyContent: 'center',
    }
});
export default App;
.....................................................................................
			   Navigation with Destructuring

import { NavigationContainer } from '@react-navigation/native';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { StyleSheet, Text, View } from 'react-native';

//create Object By calling createNativeStackNavigator function 
const { Navigator, Screen } = createNativeStackNavigator()

export const HomeScreen = props => {
    return <View style={styles.container}>
        <Text>Home Screen</Text>
    </View>
}


const App = () => {
    return <NavigationContainer>
        <Navigator>
            <Screen name="Home" component={HomeScreen} />
        </Navigator>
    </NavigationContainer>
}

const styles = StyleSheet.create({
    container: {
        flex: 1,
        backgroundColor: '#fff',
        alignItems: 'center',
        justifyContent: 'center',
    }
});
export default App;
....................................................................................
			   How to move between screens
..................................................................................

Navigating to a new screen​

Every Component receives information from the parent component as a prop.
When component is rendered via route,React Navigator injects an object called "Navigation" Object as prop to every Component


Props;
Object {
  "navigation": Object {
    "addListener": [Function addListener],
    "canGoBack": [Function canGoBack],
    "dispatch": [Function dispatch],
    "getId": [Function getId],
    "getParent": [Function getParent],
    "getState": [Function anonymous],
    "goBack": [Function anonymous],
    "isFocused": [Function isFocused],
    "navigate": [Function anonymous],
    "pop": [Function anonymous],
    "popToTop": [Function anonymous],
    "push": [Function anonymous],
    "removeListener": [Function removeListener],
    "replace": [Function anonymous],
    "reset": [Function anonymous],
    "setOptions": [Function setOptions],
    "setParams": [Function anonymous],
  },
  "route": Object {
    "key": "Home-V-z_dGCJfqcHgNXxzxRGK",
    "name": "Home",
    "params": undefined,
  },

import { NavigationContainer } from '@react-navigation/native';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { StyleSheet, Text, View, Button } from 'react-native';

//create Object By calling createNativeStackNavigator function 
const { Navigator, Screen } = createNativeStackNavigator()

export const HomeScreen = props => {
    console.log('home', props)
    const { navigation } = props;
    const moveToScreen = () => {
       // props.navigation.navigate('Details')
       navigation.navigate('Details')
    }
    return <View style={styles.container}>
        <Text>Home Screen</Text>
        <Button title="Go Details" onPress={moveToScreen} />
    </View>
}
export const DetailsScreen = props => {
    return <View style={styles.container}>
        <Text>Details Screen</Text>
    </View>
}

const App = () => {
    return <NavigationContainer>
        <Navigator>
            {/* Routes  name of the route is represented by name */}
            <Screen name="Home" component={HomeScreen} />
            <Screen name="Details" component={DetailsScreen} />
        </Navigator>
    </NavigationContainer>
}

const styles = StyleSheet.create({
    container: {
        flex: 1,
        backgroundColor: '#fff',
        alignItems: 'center',
        justifyContent: 'center',
    }
});
export default App;


navigation - the navigation prop is passed in to every screen component (definition) in the native stack navigator 

navigate('Details') - we call the navigate function (on the navigation prop — naming is hard!) with the name of the route that we'd like to move the user to.
.....................................................................................
			    Moving Screens from back to forth
.....................................................................................

There are two ways
1.Using back button as part of status bar.
2.Using code
  navigation.goBack()
  or
  navigation.navigate('screen')

import { NavigationContainer } from '@react-navigation/native';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { StyleSheet, Text, View, Button } from 'react-native';

//create Object By calling createNativeStackNavigator function 
const { Navigator, Screen } = createNativeStackNavigator()

export const HomeScreen = props => {
    console.log('home', props)
    const { navigation } = props;
    const moveToScreen = () => {
       // props.navigation.navigate('Details')
       navigation.navigate('Details')
    }
    return <View style={styles.container}>
        <Text>Home Screen</Text>
        <Button title="Go Details" onPress={moveToScreen} />
    </View>
}
export const DetailsScreen = props => {
    const {navigation} = props;
    return <View style={styles.container}>
        <Text>Details Screen</Text>
        <Button title="Go Back" onPress={()=>{
            navigation.goBack();
        }} />
    <Button title="Go to Home" onPress={() => navigation.navigate('Home')} />

    </View>
}

const App = () => {
    return <NavigationContainer>
        <Navigator>
            {/* Routes  name of the route is represented by name */}
            <Screen name="Home" component={HomeScreen} />
            <Screen name="Details" component={DetailsScreen} />
        </Navigator>
    </NavigationContainer>
}

const styles = StyleSheet.create({
    container: {
        flex: 1,
        backgroundColor: '#fff',
        alignItems: 'center',
        justifyContent: 'center',
    }
});
export default App;
....................................................................................
                       Navigate to a route multiple times​

The navigate function roughly means "go to this screen", and if you are already on that screen then it makes sense that it would do nothing.

Let's suppose that we actually want to add another details screen. This is pretty common in cases where you pass in some unique data to each route.To do this, we can change navigate to push. This allows us to express the intent to add another route regardless of the existing navigation history.

<Button
  title="Go to Details... again"
  onPress={() => navigation.push('Details')}
/>
import { NavigationContainer } from '@react-navigation/native';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { StyleSheet, Text, View, Button } from 'react-native';

//create Object By calling createNativeStackNavigator function 
const { Navigator, Screen } = createNativeStackNavigator()

export const HomeScreen = props => {
    console.log('home', props)
    const { navigation } = props;
    const moveToScreen = () => {
        // props.navigation.navigate('Details')
        navigation.navigate('Details')
    }
    return <View style={styles.container}>
        <Text>Home Screen</Text>
        <Button title="Go Details" onPress={moveToScreen} />
    </View>
}
export const DetailsScreen = props => {
    const { navigation } = props;
    return <View style={styles.container}>
        <Text>Details Screen</Text>
        <Button
            title="Go to Details... again"
            onPress={() => navigation.push('Details')}
        />
        <Button title="Go Back" onPress={() => {
            navigation.goBack();
        }} />
        <Button title="Go to Home" onPress={() => navigation.navigate('Home')} />

    </View>
}

const App = () => {
    return <NavigationContainer>
        <Navigator>
            {/* Routes  name of the route is represented by name */}
            <Screen name="Home" component={HomeScreen} />
            <Screen name="Details" component={DetailsScreen} />
        </Navigator>
    </NavigationContainer>
}

const styles = StyleSheet.create({
    container: {
        flex: 1,
        backgroundColor: '#fff',
        alignItems: 'center',
        justifyContent: 'center',
    }
});
export default App;
....................................................................................
				
Router Properties: Screen Props:
...............................

Specifying options:
..................
Each screen in the navigator can specify some options for the navigator, such as the title to render in the header. These options can be passed in the options prop for each screen component:

<Stack.Screen
  name="Home"
  component={HomeScreen}
  options={{ title: 'Welcome to Start Token' }}
/>
..................................................................................
				How to pass data to the Compoent via Props

Passing additional props#
.........................

Sometimes we might want to pass additional props to a screen.

We can do that with 2 approaches:

1.Use React context and wrap the navigator with a context provider to pass data to the screens (recommended).

2.Use a render callback for the screen instead of specifying a component prop:


import { NavigationContainer } from '@react-navigation/native';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { StyleSheet, Text, View, Button } from 'react-native';

//create Object By calling createNativeStackNavigator function 
const { Navigator, Screen } = createNativeStackNavigator()

export const HomeScreen = props => {
    const { navigation } = props;
    const moveToScreen = () => {
        navigation.navigate('Details')
    }
    return <View style={styles.container}>
        <Text>{props.title}</Text>
        <Button title="Go Details" onPress={moveToScreen} />
    </View>
}
HomeScreen.defaultProps = {
    title: 'Your Bank'
}

export const DetailsScreen = props => {
    const { navigation } = props;
    return <View style={styles.container}>
        <Text>Details Screen</Text>
        <Button
            title="Go to Details... again"
            onPress={() => navigation.push('Details')}
        />
        <Button title="Go Back" onPress={() => {
            navigation.goBack();
        }} />
        <Button title="Go to Home" onPress={() => navigation.navigate('Home')} />

    </View>
}

const App = () => {
    return <NavigationContainer>
        <Navigator>
            {/* Routes  name of the route is represented by name */}
            {/* <Screen name="Home" options={{ title: 'Welcome to Start Token' }} component={HomeScreen} /> */}
            <Screen name="Home" options={{ title: 'Welcome to Start Token' }}>
                {props => {
                    return <HomeScreen {...props}  title="Bank of India - Home" />
                }}
            </Screen>

            <Screen name="Details" component={DetailsScreen} />
        </Navigator>
    </NavigationContainer>
}

const styles = StyleSheet.create({
    container: {
        flex: 1,
        backgroundColor: '#fff',
        alignItems: 'center',
        justifyContent: 'center',
    }
});
export default App;
.....................................................................................
How to tell which routes should be displayed first? - as Home

1.Generally Based on order the first screen will be rendered as Home Route.
2.In the Navigator , we can tell "initialRouteName"

With Screen Order:
  <NavigationContainer>
            <Navigator>
	
                <Screen name="Home"  options={{ title: 'Welcome to Start Token' }}>
                    {props => <HomeScreen {...props} extraData={"Start Token"} />}
                </Screen>
              
                <Screen  name="Details" component={DetailsScreen} />
            </Navigator>
        </NavigationContainer>


With inital Route Name
eg:
  <NavigationContainer>
            <Navigator initialRouteName="Details">
                {/* <Screen options={{ title: 'Welcome to Start Token' }} name="Home" component={HomeScreen} /> */}
                <Screen name="Home"  options={{ title: 'Welcome to Start Token' }}>
                    {props => <HomeScreen {...props} extraData={"Start Token"} />}
                </Screen>
              
                <Screen  name="Details" component={DetailsScreen} />
            </Navigator>
        </NavigationContainer>
Recap:

React Native doesn't have a built-in API for navigation like a web browser does. React Navigation provides this for you, along with the iOS and Android gestures and animations to transition between screens.

Stack.Navigator is a component that takes route configuration as its children with additional props for configuration and renders our content.

Each Stack.Screen component takes a name prop which refers to the name of the route and component prop which specifies the component to render for the route. These are the 2 required props.

To specify what the initial route in a stack is, provide an initialRouteName as the prop for the navigator.

To specify screen-specific options, we can pass an options prop to Stack.Screen, and for common options, we can pass screenOptions to Stack.Navigator
.....................................................................................
.............................................................................................
                                        Passing parameters to routes
............................................................................................

Now that we know how to create a stack navigator with some routes and navigate between those routes, let's look at how we can pass data to routes when we navigate to them.

There are two pieces to this:

Pass params to a route by putting them in an object as a second parameter to the navigation.navigate function: navigation.navigate('RouteName', { /* params go here */ })

import { NavigationContainer } from '@react-navigation/native';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { StyleSheet, Text, View, Button } from 'react-native';

//create Object By calling createNativeStackNavigator function 
const { Navigator, Screen } = createNativeStackNavigator()

export const HomeScreen = props => {
    const { navigation } = props;
    const moveToScreen = () => {
        navigation.navigate('Details', { message: 'Hello' })
    }
    return <View style={styles.container}>
        <Text>{props.title}</Text>
        <Button title="Go Details" onPress={moveToScreen} />
    </View>
}
HomeScreen.defaultProps = {
    title: 'Your Bank'
}

export const DetailsScreen = props => {
    const { navigation, route: { params: { message } } } = props;
    // console.log(route)

    return <View style={styles.container}>
        <Text>Details Screen</Text>
        <Text>Data From Home Screen {message}</Text>
        <Button
            title="Go to Details... again"
            onPress={() => navigation.push('Details')}
        />
        <Button title="Go Back" onPress={() => {
            navigation.goBack();
        }} />
        <Button title="Go to Home" onPress={() => navigation.navigate('Home')} />

    </View>
}

const App = () => {
    return <NavigationContainer>
        <Navigator initialRouteName='Home'>
            <Screen name="Home" options={{ title: 'Welcome to Start Token' }}>
                {props => {
                    return <HomeScreen {...props} title="Bank of India - Home" />
                }}
            </Screen>

            <Screen name="Details" component={DetailsScreen} />
        </Navigator>
    </NavigationContainer>
}

const styles = StyleSheet.create({
    container: {
        flex: 1,
        backgroundColor: '#fff',
        alignItems: 'center',
        justifyContent: 'center',
    }
});
export default App;
.....................................................................................
		Connecting to WebService,Get Data and show with Routing

import { NavigationContainer } from '@react-navigation/native';
import React, { useEffect, useState } from 'react';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { View, Text, FlatList, StatusBar, Button, ActivityIndicator, StyleSheet, Alert } from 'react-native';

//create Object By calling createNativeStackNavigator function 
const { Navigator, Screen } = createNativeStackNavigator()

export const HomeScreen = props => {
    const { navigation } = props;
    const moveToScreen = () => {
        navigation.navigate('Post')
    }
    return <View style={styles.container}>
        <Button title="Post" onPress={moveToScreen} />
    </View>
}
HomeScreen.defaultProps = {
    title: ''
}

export const PostDetailsScreen = props => {
    const { navigation, route: { params: { item } } } = props;
    console.log(item)
    return <View style={styles.container}>
        <Text>{
            JSON.stringify(item)
        }</Text>
    </View>
}

export const PostScreen = props => {

    const { navigation } = props;

    const [posts, setPosts] = useState({
        error: null, // if any ajax error
        isLoaded: false, //Progress bar enabler
        items: []  // data to be filed
    })

    //componentDid == useEffect 
    useEffect(() => {
        const url = 'https://jsonplaceholder.typicode.com/posts'
        fetch(url)
            .then(res => res.json())
            .then(posts => {
                setTimeout(() => {
                    setPosts(prvState => {
                        return { ...prvState, isLoaded: true, items: posts }
                    });
                }, 0)

            }, (error) => {
                setPosts({
                    isLoaded: true,
                    error
                });
            })

    }, [])


    const onPressItem = item => {
        navigation.navigate('PostDetails', { item: item })
    }
    //use object destructuring
    const { error, items, isLoaded } = posts;

    if (error) {
        //render error component
        return <View style={styles.error}> Error: {error.message}</View>;
    } else if (!isLoaded) {
        return <View style={styles.loader}>
            <ActivityIndicator size="large" color="#00ff00" />
        </View>;
    } else {
        return <View styles={styles.container}>
            <FlatList
                keyExtractor={(post) => {
                    return post.id
                }}
                data={items}
                renderItem={
                    ({ item }) => {
                        const { title } = item
                        return <View style={styles.item}>
                            <Text onPress={() => { onPressItem(item) }} style={styles.title}>{title}</Text>
                        </View>
                    }
                }
            />
        </View>
    }

}





const App = () => {
    return <NavigationContainer>
        <Navigator initialRouteName='Home'>
            <Screen name="Home" options={{ title: 'Post Application' }}>
                {props => {
                    return <HomeScreen {...props} />
                }}
            </Screen>
            <Screen name="Post" component={PostScreen} />
            <Screen name="PostDetails" component={PostDetailsScreen} />
        </Navigator>
    </NavigationContainer>
}

const styles = StyleSheet.create({
    container: {
        flex: 1,
        marginTop: StatusBar.currentHeight || 0,
    },
    item: {
        backgroundColor: '#f9c2ff',
        padding: 20,
        marginVertical: 8,
        marginHorizontal: 16,
    },
    title: {
        fontSize: 32,
    },
});
export default App;
.....................................................................................
			   setParams

Updating params#
Screens can also update their params, like they can update their state. The navigation.setParams method lets you update the params of a screen.
Basic usage:

navigation.setParams({
  query: 'someText',
})



import { NavigationContainer } from '@react-navigation/native';
import React, { useEffect, useState } from 'react';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { View, Text, FlatList, StatusBar, Button, ActivityIndicator, StyleSheet, Alert } from 'react-native';



//create Stack Object
const { Navigator, Screen } = createNativeStackNavigator();

const HomeScreen = props => {
    const { navigation, route } = props;
    return <View style={styles.container}>
        <Text>Home Screen : {props.extraData}</Text>
        <Button title="Go to Details" onPress={() => navigation.navigate('Details', { id: 1, item: 'React Native' })} />
    </View>
}
const DetailsScreen = (props) => {
    const { navigation, route } = props;
    console.log(route.params);
    return (
        <View style={styles.container}>
            <Text>Details Screen : {route.params.id} - {route.params.item}</Text>
            <Button
                title="Go to Details... again"
                onPress={() => {
                    // navigation.push('Details', {
                    //     id: Math.floor(Math.random() * 100),
                    // })
                    navigation.setParams({ id: 900, item: 'foo' })
                }
                }
            />
        </View>
    );
}

const App = () => {
    return <NavigationContainer>
        <Navigator initialRouteName='Home'>
            <Screen name="Home" component={HomeScreen} options={{ title: 'Welcome to Start Token' }} />
            <Screen name="Details" component={DetailsScreen} />
        </Navigator>
    </NavigationContainer>
}

const styles = StyleSheet.create({
    container: {
        flex: 1,
        backgroundColor: '#fff',
        alignItems: 'center',
        justifyContent: 'center',
    },
});


export default App;
.....................................................................................
Initial params#
You can also pass some initial params to a screen. If you didn't specify any params when navigating to this screen, the initial params will be used. They are also shallow merged with any params that you pass. Initial params can be specified with an initialParams prop:

<Stack.Screen
  name="Details"
  component={DetailsScreen}
  initialParams={{ itemId: 42 }}
/>


import { NavigationContainer } from '@react-navigation/native';
import React, { useEffect, useState } from 'react';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { View, Text, FlatList, StatusBar, Button, ActivityIndicator, StyleSheet, Alert } from 'react-native';



//create Stack Object
const { Navigator, Screen } = createNativeStackNavigator();

const HomeScreen = props => {
    const { navigation, route } = props;
    return <View style={styles.container}>
        <Text>Home Screen : {props.extraData}</Text>
        <Button title="Go to Details" onPress={() => navigation.navigate('Details')} />
    </View>
}
const DetailsScreen = (props) => {
    const { navigation, route } = props;
    console.log(route.params);
    return (
        <View style={styles.container}>
            <Text>Details Screen : {route.params.id} - {route.params.item}</Text>
            <Button
                title="Go to Details... again"
                onPress={() => {
                    // navigation.push('Details', {
                    //     id: Math.floor(Math.random() * 100),
                    // })
                    navigation.setParams({ id: 900, item: 'foo' })
                }
                }
            />
        </View>
    );
}

const App = () => {
    return <NavigationContainer>
        <Navigator initialRouteName='Home'>
            <Screen name="Home" component={HomeScreen} options={{ title: 'Welcome to Start Token' }} />
            <Screen name="Details" initialParams={{ id: 1, item: 'React Native v2' }} component={DetailsScreen} />
        </Navigator>
    </NavigationContainer>
}

const styles = StyleSheet.create({
    container: {
        flex: 1,
        backgroundColor: '#fff',
        alignItems: 'center',
        justifyContent: 'center',
    },
});


export default App;
.....................................................................................
Passing params to a previous screen#

Params aren't only useful for passing some data to a new screen, but they can also be useful to pass data to a previous screen too. For example, let's say you have a screen with a create post button, and the create post button opens a new screen to create a post. After creating the post, you want to pass the data for the post back to previous screen.



import { NavigationContainer } from '@react-navigation/native';
import React, { useState, useEffect } from 'react';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { View, Text, TextInput, Button, StyleSheet } from 'react-native';



//create Stack Object
const { Navigator, Screen } = createNativeStackNavigator();

const HomeScreen = props => {
    const { navigation, route } = props;

    //DidMount,DidUpdate
    useEffect(() => {
        if (route.params?.post) {
            // Post updated, do something with `route.params.post`
            // For example, send the post to the server
        }
    }, [route.params?.post]);

    return <View style={{ flex: 1, alignItems: 'center', justifyContent: 'center' }}>
        <Button
            title="Create post"
            onPress={() => navigation.navigate('CreatePost')}
        />
        <Text style={{ margin: 10 }}>Post: {route.params?.post}</Text>
    </View>
}
const CreatePostScreen = (props) => {
    const { navigation, route } = props;

    const [postText, setPostText] = useState('');

    return (<View style={styles.container}>
        <TextInput
            multiline
            placeholder="What's on your mind?"
            style={{ height: 200, padding: 10, backgroundColor: 'green' }}
            value={postText}
            onChangeText={setPostText}
        />
        <Button
            title="Done"
            onPress={() => {
                // Pass params back to home screen
                navigation.navigate('Home', { post: postText });
            }}
        />
    </View>
    );
}

const App = () => {
    return <NavigationContainer>
        <Navigator initialRouteName='Home'>
            <Screen name="Home" component={HomeScreen} options={{ title: 'PostMaster' }} />
            <Screen component={CreatePostScreen} name="CreatePost" />
        </Navigator>
    </NavigationContainer>
}

const styles = StyleSheet.create({
    container: {
        flex: 1,
        backgroundColor: '#fff',
        alignItems: 'center',
        justifyContent: 'center',
    },
});


export default App;
.....................................................................................

What should be in params#
It's important to understand what kind of data should be in params. Params are like options for a screen. They should only contain information to configure what's displayed in the screen. Avoid passing the full data which will be displayed on the screen itself (e.g. pass an user id instead of user object). Also avoid passing data which is used by multiple screens, such data should be in a global store.

You can also think of the route object like a URL. If your screen had a URL, what should be in the URL? Params shouldn't contain data that you think should not be in the URL. This often means that you should keep as little data as possible needed to determine what the screen is. Think of visiting a shopping website, when you are seeing product listings, the URL usually contains category name, type of sort, any filters etc., it doesn't contain the actual list of products displayed on the screen.

For example, say if you have a Profile screen. When navigating to it, you might be tempted to pass the user object in the params:


// Don't do this
navigation.navigate('Profile', {
  user: {
    id: 'jane',
    firstName: 'Jane',
    lastName: 'Done',
    age: 25,
  },
});
This looks convenient, and lets you access the user objects with route.params.user without any extra work.


Recap:
navigate and push accept an optional second argument to let you pass parameters to the route you are navigating to. For example: navigation.navigate('RouteName', { paramName: 'value' }).
You can read the params through route.params inside a screen
You can update the screen's params with navigation.setParams
Initial params can be passed via the initialParams prop on Screen
Params should contain the minimal data required to show a screen, nothing more.
....................................................................................
Configuring the header bar

We've seen how to configure the header title already, but let's go over that again before moving on to some other options

A Screen component accepts options prop which is either an object or a function that returns an object, that contains various configuration options. The one we use for the header title is title, as shown in the following example.


import { NavigationContainer } from '@react-navigation/native';
import React, { useState, useEffect } from 'react';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { View, Text, TextInput, Button, StyleSheet } from 'react-native';



//create Stack Object
const { Navigator, Screen } = createNativeStackNavigator();

const HomeScreen = props => {
    const { navigation, route } = props;

    //DidMount,DidUpdate
    useEffect(() => {
        if (route.params?.post) {
            // Post updated, do something with `route.params.post`
            // For example, send the post to the server
        }
    }, [route.params?.post]);

    return <View style={{ flex: 1, alignItems: 'center', justifyContent: 'center' }}>
        <Button
            title="Create post"
            onPress={() => navigation.navigate('CreatePost' ,{title:'My Post Screen'})}
        />
        <Text style={{ margin: 10 }}>Post: {route.params?.post}</Text>
    </View>
}
const CreatePostScreen = (props) => {
    const { navigation, route } = props;

    const [postText, setPostText] = useState('');

    return (<View style={styles.container}>
        <TextInput
            multiline
            placeholder="What's on your mind?"
            style={{ height: 200, padding: 10, backgroundColor: 'green' }}
            value={postText}
            onChangeText={setPostText}
        />
        <Button
            title="Done"
            onPress={() => {
                // Pass params back to home screen
                navigation.navigate('Home', { post: postText });
            }}
        />
    </View>
    );
}

const App = () => {
    return <NavigationContainer>
        <Navigator initialRouteName='Home'>
            <Screen name="Home" component={HomeScreen} options={{ title: 'PostMaster' }} />
            {/* <Screen component={CreatePostScreen} name="CreatePost" options={{
                title:"Post Form"
            }} /> */}
            <Screen
                name="CreatePost"
                component={CreatePostScreen}
                options={({ route }) => ({ title: route.params.title })}
            />
        </Navigator>
    </NavigationContainer>
}

const styles = StyleSheet.create({
    container: {
        flex: 1,
        backgroundColor: '#fff',
        alignItems: 'center',
        justifyContent: 'center',
    },
});


export default App;
................................................................................
				Update title with setOptions


Updating options with setOptions#
.................................


import { NavigationContainer } from '@react-navigation/native';
import React, { useState, useEffect } from 'react';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { View, Text, TextInput, Button, StyleSheet } from 'react-native';



//create Stack Object
const { Navigator, Screen } = createNativeStackNavigator();

const HomeScreen = props => {
    const { navigation, route } = props
    return <View style={{ flex: 1, alignItems: 'center', justifyContent: 'center' }}>
        <Text>Home Screen</Text>
        <Button
            title="Update the title"
            onPress={() => navigation.setOptions({ title: 'Updated!' })}
        />
    </View>
}


const App = () => {
    return <NavigationContainer>
        <Navigator initialRouteName='Home'>
            <Screen name="Home" component={HomeScreen} options={{ title: 'PostMaster' }} />

        </Navigator>
    </NavigationContainer>
}

const styles = StyleSheet.create({
    container: {
        flex: 1,
        backgroundColor: '#fff',
        alignItems: 'center',
        justifyContent: 'center',
    },
});


export default App;

Adjusting header styles#
.........................


There are three key properties to use when customizing the style of your header: headerStyle, headerTintColor, and headerTitleStyle.

headerStyle: a style object that will be applied to the View that wraps the header. If you set backgroundColor on it, that will be the color of your header.

headerTintColor: the back button and title both use this property as their color. In the example below, we set the tint color to white (#fff) so the back button and the header title would be white.

headerTitleStyle: if we want to customize the fontFamily, fontWeight and other Text style properties for the title, we can use this to do it.


import { NavigationContainer } from '@react-navigation/native';
import React from 'react';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { View, Text, TextInput, Button, StyleSheet } from 'react-native';



//create Stack Object
const { Navigator, Screen } = createNativeStackNavigator();

const HomeScreen = props => {
    const { navigation, route } = props
    return <View style={{ flex: 1, alignItems: 'center', justifyContent: 'center' }}>
        <Text>Home Screen</Text>
        <Button
            title="Update the title"
            onPress={() => navigation.setOptions({ title: 'Updated!' })}
        />
    </View>
}
function ProfileScreen({ navigation }) {
    return (
        <View style={{ flex: 1, alignItems: 'center', justifyContent: 'center' }}>
            <Text>Profile screen</Text>
            <Button title="Go back" onPress={() => navigation.goBack()} />
        </View>
    );
}

const App = () => {
    return <NavigationContainer>
        <Navigator initialRouteName='Home' screenOptions={
            {
                headerStyle: {
                    backgroundColor: 'pink'
                }
            }
        }>
            <Screen name="Home" component={HomeScreen} options={
                { title: 'Home', headerStyle: { backgroundColor: '#f4511e', headerTintColor: '#fff' } }} />
            <Screen
                name="Profile"
                component={ProfileScreen}
                options={{ title: 'Profile Screen' }}
            />

        </Navigator>
    </NavigationContainer>
}

const styles = StyleSheet.create({
    container: {
        flex: 1,
        backgroundColor: '#fff',
        alignItems: 'center',
        justifyContent: 'center',
    },
});


export default App;



Sharing common options across screens#

It is common to want to configure the header in a similar way across many screens. For example, your company brand color might be red and so you want the header background color to be red and tint color to be white. Conveniently, these are the colors we're using in our running example, and you'll notice that when you navigate to the DetailsScreen the colors go back to the defaults. Wouldn't it be awful if we had to copy the options header style properties from HomeScreen to DetailsScreen, and for every single screen component we use in our app? Thankfully, we do not. We can instead move the configuration up to the stack navigator under the prop screenOptions


//create Stack Object
const { Navigator, Screen } = createNativeStackNavigator();

const HomeScreen = props => {
    const { navigation, route } = props
    return <View style={{ flex: 1, alignItems: 'center', justifyContent: 'center' }}>
        <Text>Home Screen</Text>
        <Button
            title="Go To Profile"
            onPress={() => navigation.navigate('Profile')}
        />
    </View>
}
function ProfileScreen({ navigation }) {
    return (
        <View style={{ flex: 1, alignItems: 'center', justifyContent: 'center' }}>
            <Text>Profile screen</Text>
            <Button title="Go back" onPress={() => navigation.goBack()} />
        </View>
    );
}

const App = () => {
    return <NavigationContainer>
        <Navigator initialRouteName='Home' screenOptions={
            {
                headerStyle: {
                    backgroundColor: 'pink'
                }
            }
        }>
            <Screen name="Home" component={HomeScreen} options={
                { title: 'Home' }} />
            <Screen
                name="Profile"
                component={ProfileScreen}
                options={{ title: 'Profile Screen' }}
            />

        </Navigator>
    </NavigationContainer>
}

const styles = StyleSheet.create({
    container: {
        flex: 1,
        backgroundColor: '#fff',
        alignItems: 'center',
        justifyContent: 'center',
    },
});


export default App;
.................................................................................
			   Header buttons


function StackScreen() {
  return (
    <Stack.Navigator>
      <Stack.Screen
        name="Home"
        component={HomeScreen}
        options={{
          headerTitle: (props) => <LogoTitle {...props} />,
          headerRight: () => (
            <Button
              onPress={() => alert('This is a button!')}
              title="Info"
              color="#fff"
            />
          ),
        }}
      />
    </Stack.Navigator>
  );

eg:
//Header Buttons
import { NavigationContainer } from '@react-navigation/native';
import React from 'react';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { View, Text, TextInput, Button, StyleSheet } from 'react-native';



//create Stack Object
const { Navigator, Screen } = createNativeStackNavigator();

const HomeScreen = props => {
    const { navigation, route } = props
    return <View style={{ flex: 1, alignItems: 'center', justifyContent: 'center' }}>
        <Text>Home Screen</Text>
        <Button
            title="Go To Profile"
            onPress={() => navigation.navigate('Profile')}
        />
    </View>
}
function ProfileScreen({ navigation }) {
    return (
        <View style={{ flex: 1, alignItems: 'center', justifyContent: 'center' }}>
            <Text>Profile screen</Text>
            <Button title="Go back" onPress={() => navigation.goBack()} />
        </View>
    );
}

function App() {
    return (<NavigationContainer>
        <Navigator>
            <Screen
                name="Home"
                component={HomeScreen}
                options={{
                    headerTitle: (props) => <Text>Header</Text> ,
                    headerRight: () => (
                        <Button
                            onPress={() => alert('This is a button!')}
                            title="Info"
                            color="black"
                        />
                    ),
                }}
            />
        </Navigator>
    </NavigationContainer>
    );
}
export default App
}
....................................................................................

Header interaction with its screen component​

To be able to interact with the screen component, we need to use navigation.setOptions to define our button instead of the options prop. By using navigation.setOptions inside the screen component, we get access to screen's props, state, context etc.
//Header Buttons
import { NavigationContainer } from '@react-navigation/native';
import React, { useState, useLayoutEffect } from 'react';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { View, Text, TextInput, Button, StyleSheet } from 'react-native';



//create Stack Object
const { Navigator, Screen } = createNativeStackNavigator();

const HomeScreen = props => {
    const [count, setCount] = useState(0);
    const { navigation } = props;
    useLayoutEffect(() => {
        navigation.setOptions({
            headerRight: () => (
                <Button onPress={() => setCount((c) => c + 1)} title="Update count" />
            ),
        });
    }, [navigation]);

    return <Text>Count: {count}</Text>;
}

function App() {
    return (<NavigationContainer>
        <Navigator>
            <Screen
                name="Home"
                component={HomeScreen}
                options={({ navigation, route }) => ({
                    headerTitle: (props) => <Text>Counter</Text>,
                })}
            />
        </Navigator>
    </NavigationContainer>
    );
}
export default App
....................................................................................
				Nested Navigation - Tabs
.....................................................................................

In web, Menu and child menus

Category

  Electronics
     Mobiles
     Computers
  Books

Nesting navigators means rendering a navigator inside a screen of another navigator, for example:

function Home() {
  return (
    <Tab.Navigator>
      <Tab.Screen name="Feed" component={Feed} />
      <Tab.Screen name="Messages" component={Messages} />
    </Tab.Navigator>
  );
}

function App() {
  return (
    <NavigationContainer>
      <Stack.Navigator>
        <Stack.Screen
          name="Home"
          component={Home}
          options={{ headerShown: false }}
        />
        <Stack.Screen name="Profile" component={Profile} />
        <Stack.Screen name="Settings" component={Settings} />
      </Stack.Navigator>
    </NavigationContainer>
  );
}

Stack.Navigator
    Home (Tab.Navigator)
	Feed (Screen)
	Messages (Screen)
Profile (Screen)
Settings (Screen)
.....................**********......................................................
Tab Navigator:
..............
npm install @react-navigation/bottom-tabs

import { createBottomTabNavigator } from '@react-navigation/bottom-tabs';

const Tab = createBottomTabNavigator();

function MyTabs() {
  return (
    <Tab.Navigator>
      <Tab.Screen name="Home" component={HomeScreen} />
      <Tab.Screen name="Settings" component={SettingsScreen} />
    </Tab.Navigator>
  );
}
//Header Buttons
import { NavigationContainer } from '@react-navigation/native';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { View, Text, StyleSheet } from 'react-native';
import { createBottomTabNavigator } from '@react-navigation/bottom-tabs';

//create Stack Object
const Tab = createBottomTabNavigator();
const Stack = createNativeStackNavigator();

const HomeScreen = props => {
    return <View style={styles.container}>
            <Text>Home</Text>
    </View>
}

const Settings = props => {
    return <View style={styles.container}>
        <Text>Settings Screen</Text>
    </View>
}
function App() {
    return <NavigationContainer>
        <Tab.Navigator>
            <Tab.Screen name="Home" component={HomeScreen} />
            <Tab.Screen name="Settings" component={Settings} />
        </Tab.Navigator>
    </NavigationContainer>

}


const styles = StyleSheet.create({
    container: {
        flex: 1,
        backgroundColor: '#fff',
        alignItems: 'center',
        justifyContent: 'center',
    },
});

export default App


...................................................................................
				Nested Navigation

//Header Buttons
import { NavigationContainer } from '@react-navigation/native';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { View, Text, StyleSheet } from 'react-native';
import { createBottomTabNavigator } from '@react-navigation/bottom-tabs';

//create Stack Object
const Tab = createBottomTabNavigator();
const Stack = createNativeStackNavigator();

const Home = props => {
    return <Tab.Navigator>
        <Tab.Screen name="Feed" component={Feed} />
        <Tab.Screen name="Messages" component={Messages} />
    </Tab.Navigator>
}

const Feed = props => {
    return <View style={styles.container}>
        <Text>Feed Screen</Text>
    </View>
}

const Messages = props => {
    return <View style={styles.container}>
        <Text>Messages Screen</Text>
    </View>
}
const Settings = props => {
    return <View style={styles.container}>
        <Text>Settings Screen</Text>
    </View>
}
function App() {
    return <NavigationContainer>
        <Stack.Navigator>
            <Stack.Screen
                name="Home"
                component={Home}
                options={{ headerShown: false }}
            />
            <Stack.Screen name="Settings" component={Settings} />
        </Stack.Navigator>
    </NavigationContainer>

}


const styles = StyleSheet.create({
    container: {
        flex: 1,
        backgroundColor: '#fff',
        alignItems: 'center',
        justifyContent: 'center',
    },
});

export default App
...................................................................................
			Navigating from tab to screen
...................................................................................

//Header Buttons
import { NavigationContainer } from '@react-navigation/native';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { View, Text, StyleSheet,Button } from 'react-native';
import { createBottomTabNavigator } from '@react-navigation/bottom-tabs';

//create Stack Object
const Tab = createBottomTabNavigator();
const Stack = createNativeStackNavigator();

const Home = props => {
    return <Tab.Navigator>
        <Tab.Screen name="Feed" component={Feed} />
        <Tab.Screen name="Messages" component={Messages} />
    </Tab.Navigator>
}

const Feed = props => {
    return <View style={styles.container}>
        <Text>Feed Screen</Text>
    </View>
}

const Messages = props => {
    const { navigation } = props;
    return <View style={styles.container}>
        <Text>Messages Screen</Text>
        <Button title="go to Settions" onPress={() => {
             navigation.navigate('Settings')
        }} />
    </View>
}
const Settings = props => {
    return <View style={styles.container}>
        <Text>Settings Screen</Text>
    </View>
}
function App() {
    return <NavigationContainer>
        <Stack.Navigator>
            <Stack.Screen
                name="Home"
                component={Home}
                options={{ headerShown: false }}
            />
            <Stack.Screen name="Settings" component={Settings} />
        </Stack.Navigator>
    </NavigationContainer>

}


const styles = StyleSheet.create({
    container: {
        flex: 1,
        backgroundColor: '#fff',
        alignItems: 'center',
        justifyContent: 'center',
    },
});

export default App
...................................................................................
			 Advanced Tabs
...................................................................................

BottomTab
TopTab

Possibly the most common style of navigation in mobile apps is tab-based navigation. This can be tabs on the bottom of the screen or on the top below the header (or even instead of a header).

1.createBottomTabNavigator.
2.createMaterialBottomTabNavigator 
3.createMaterialTopTabNavigator 

Customizing the appearance​

npm i @expo/vector-icons

// You can import Ionicons from @expo/vector-icons/Ionicons if you use Expo or
// react-native-vector-icons/Ionicons otherwise.
import Ionicons from 'react-native-vector-icons/Ionicons';

// (...)

export default function App() {
  return (
    <NavigationContainer>
      <Tab.Navigator
        screenOptions={({ route }) => ({
          tabBarIcon: ({ focused, color, size }) => {
            let iconName;

            if (route.name === 'Home') {
              iconName = focused
                ? 'ios-information-circle'
                : 'ios-information-circle-outline';
            } else if (route.name === 'Settings') {
              iconName = focused ? 'ios-list-box' : 'ios-list';
            }

            // You can return any component that you like here!
            return <Ionicons name={iconName} size={size} color={color} />;
          },
          tabBarActiveTintColor: 'tomato',
          tabBarInactiveTintColor: 'gray',
        })}
      >
        <Tab.Screen name="Home" component={HomeScreen} />
        <Tab.Screen name="Settings" component={SettingsScreen} />
      </Tab.Navigator>
    </NavigationContainer>
  );
}

eg:
//Header Buttons
import { NavigationContainer } from '@react-navigation/native';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { View, Text, StyleSheet, Button } from 'react-native';
import { createBottomTabNavigator } from '@react-navigation/bottom-tabs';
import Ionicons from 'react-native-vector-icons/Ionicons';
//create Stack Object
const Tab = createBottomTabNavigator();
const Stack = createNativeStackNavigator();

const Home = props => {
    console.log(props.route.name)
    return <Text>Home</Text>
}

const Feed = props => {
    return <View style={styles.container}>
        <Text>Feed Screen</Text>
    </View>
}

const Messages = props => {
    return <View style={styles.container}>
        <Text>Messages Screen</Text>

    </View>
}
const Settings = props => {
    return <View style={styles.container}>
        <Text>Settings Screen</Text>
    </View>
}
function App() {
    return <NavigationContainer>
        <Tab.Navigator
            screenOptions={({ route }) => ({
                tabBarIcon: ({ focused, color, size }) => {
                    //console.log(route, focused, color, size)
                    console.log(route)
                    if (route.name==='Feed') {
                        return <Ionicons name="md-checkmark-circle" size={32} color="green" />
                    }
                    //https://ionic.io/ionicons
                    return <Ionicons name="cart-outline" size={32} color="red" />
                },
                tabBarActiveTintColor: 'tomato',
                tabBarInactiveTintColor: 'gray',
            })}
        >
            <Tab.Screen name="Feed" component={Feed} />
            <Tab.Screen name="Messages" component={Messages} />
        </Tab.Navigator>
    </NavigationContainer>

}


const styles = StyleSheet.create({
    container: {
        flex: 1,
        backgroundColor: '#fff',
        alignItems: 'center',
        justifyContent: 'center',
    },
});

export default App
...................................................................................
			       Drawer Navigation
...................................................................................

Common pattern in navigation is to use drawer from left (sometimes right) side for navigating between screens.

Rules:

1.npm install @react-navigation/drawer
2.expo install react-native-gesture-handler react-native-reanimated
2.import 'react-native-gesture-handler';
   this must be top level import
3.babel.config.js

module.exports = function (api) {
  api.cache(true);
  return {
    presets: ['babel-preset-expo'],
    plugins: [
      'react-native-reanimated/plugin',
    ],
  };
};






import * as React from 'react';
import { Button, View } from 'react-native';
import { createDrawerNavigator } from '@react-navigation/drawer';
import { NavigationContainer } from '@react-navigation/native';

function HomeScreen({ navigation }) {
  return (
    <View style={{ flex: 1, alignItems: 'center', justifyContent: 'center' }}>
      <Button
        onPress={() => navigation.navigate('Notifications')}
        title="Go to notifications"
      />
    </View>
  );
}

function NotificationsScreen({ navigation }) {
  return (
    <View style={{ flex: 1, alignItems: 'center', justifyContent: 'center' }}>
      <Button onPress={() => navigation.goBack()} title="Go back home" />
    </View>
  );
}

const Drawer = createDrawerNavigator();

export default function App() {
  return (
    <NavigationContainer>
      <Drawer.Navigator initialRouteName="Home">
        <Drawer.Screen name="Home" component={HomeScreen} />
        <Drawer.Screen name="Notifications" component={NotificationsScreen} />
      </Drawer.Navigator>
    </NavigationContainer>
  );
}
...................................................................................
				Device Specific Apis

/////////////////////////////////////////////////////////////////////////////////////////////
                       Device features-Mobile App Components-React Native Advanced Components
..............................................................................................

In order to work with Device features:

When you are creating an app that requires access to potentially senstive information on user's device, such as their location, contacts,camera ...you need to ask for the user's permission first.

How to get permission from the device?

expo provides an module to work with permissions on both platforms.

$ expo install expo-permissions

Note : if you are working with particular device feature, device specific permission
package must also be installed


Permission      type	Packages

NOTIFICATIONS	expo-notifications

USER_FACING_NOTIFICATIONS	expo-notifications

LOCATION	expo-location

CAMERA	expo-barcode-scanner expo-camera 
        expo-face-detector expo-image-picker expo-media-library

AUDIO_RECORDING	expo-av

CONTACTS	expo-contacts

MEDIA_LIBRARY MEDIA_LIBRARY_WRITE_ONLY	expo-image-picker
                                        expo-media-library
CALENDAR	expo-calendar

REMINDERS	expo-calendar

SYSTEM_BRIGHTNESS expo-brightness

MOTION   expo-sensors	


import * as Permission from 'expo-permission'

Objects:

1.PermissionResponse

 status: 'granted'|'denied'|'undermined'
 granted: boolean
 expires: 'never' | number
 
....................................................................................

Async Programming Styles:

callbacks
Promises
async await


How to use async...await?

//callbacks:  function to be registered incase of async programming.

function connect(callback) {
    //async api ; timers,ajax api,websockets
    setTimeout(callback, 1000, "Greet")
}

function dbconnect() {
    return new Promise((resolve, reject) => {
        setTimeout(resolve, 3000, "Greet-Promise")
    })
}

async function main() {
    console.log('start')
    connect(function (data) {
        console.log(data)
    })
    dbconnect()
        .then(data => console.log(data))
        .catch(err => console.log(err))

    try {
        const data = await dbconnect()
        console.log(data)
        console.log('end')
    }
    catch(err){
        console.log(err)
    }
}
main()
....................................................................................

How to use async and await keywords inside useEffect

with Promises
useEffect(()=>{

fetch('https://reactnative.dev/movies.json')
            .then((response) => response.json())
            .then((json) => setData(json.movies))
            .catch((error) => console.error(error))
            .finally(() => setLoading(false));
},[])

with async ...await keywords

write a separe function and call it.

async function init() {
            try {
                const response = await fetch('https://reactnative.dev/movies.json')
                const json = await response.json();
                const data = json.movies;
                setData(data);
            }
            catch (e) {
                console.log(error)
            }
            finally {
                setLoading(false)
            }
}
init();

 //IIFE Syntax
(OUR CODE)()

         (async function(){
            try {
                const response = await fetch('https://reactnative.dev/movies.json')
                const json = await response.json();
                const data = json.movies;
                setData(data);
            }
            catch (e) {
                console.log(error)
            }
            finally {
                setLoading(false)
            }
         })();


eg:

expo install expo-location


import React, { useState, useEffect } from 'react';
import { Platform, Text, View, StyleSheet } from 'react-native';
import * as Location from 'expo-location';

export default function App() {
    const [location, setLocation] = useState(null);
    const [errorMsg, setErrorMsg] = useState(null);

    useEffect(() => {
        (async () => {
            let { status } = await Location.requestForegroundPermissionsAsync();
            if (status !== 'granted') {
                setErrorMsg('Permission to access location was denied');
                return;
            }

            let location = await Location.getCurrentPositionAsync({});
            setLocation(location);
        })();
    }, []);

    let text = 'Waiting..';
    if (errorMsg) {
        text = errorMsg;
    } else if (location) {
        text = JSON.stringify(location);
    }

    return (
        <View style={styles.container}>
            <Text style={styles.paragraph}>{text}</Text>
        </View>
    );
}

const styles = StyleSheet.create({
    container: {
        flex: 1,
        backgroundColor: '#fff',
        alignItems: 'center',
        justifyContent: 'center',
    },
});
.....................................................................................
Map and Location


npm install react-native-maps

import React, { useState, useEffect } from 'react';
import { StyleSheet, Text, View, Dimensions } from 'react-native';
import MapView from 'react-native-maps';
import * as Location from 'expo-location';

export default function App() {
    const [location, setLocation] = useState(null);
    const [errorMsg, setErrorMsg] = useState(null);
    useEffect(() => {
        (async () => {
            let { status } = await Location.requestForegroundPermissionsAsync();
            if (status !== 'granted') {
                setErrorMsg('Permission to access location was denied');
                return;
            }

            let location = await Location.getCurrentPositionAsync({});
            setLocation(location);
        })();
    }, []);

    let text = 'Waiting..';
    if (errorMsg) {
        text = errorMsg;
    } else if (location) {
        text = JSON.stringify(location);
        console.log(location);
    }
    if (!location) {
        return <View style={styles.container}>
            <Text>No Location found!</Text>
        </View>
    }

    return (<MapView style={{ flex: 1 }} initialRegion={{
        latitude: location.coords.latitude,
        longitude: location.coords.longitude,
        latitudeDelta: 0.0922,
        longitudeDelta: 0.0421,
    }} provider={MapView.PROVIDER_GOOGLE} />);

}

const styles = StyleSheet.create({
    container: {
        flex: 1,
        backgroundColor: '#fff',
        alignItems: 'center',
        justifyContent: 'center',
    },
    map: {
        width: Dimensions.get('window').width,
        height: Dimensions.get('window').height,
    },
});
.....................................................................................

How to access Contacts?

expo-contacts proivdes access to the devices system contacts, allowing you to get contact information as well as adding , editing, removing contacts.

expo install expo-contacts


import React, { useEffect } from 'react';
import { StyleSheet, View, Text } from 'react-native';
import * as Contacts from 'expo-contacts';

export default function App() {
    useEffect(() => {
        (async () => {
            const { status } = await Contacts.requestPermissionsAsync();
            if (status === 'granted') {
                const { data } = await Contacts.getContactsAsync({
                    fields: [Contacts.Fields.Emails],
                });

                if (data.length > 0) {
                    const contact = data;
                    console.log(contact);
                }
            }
        })();
    }, []);

    return (
        <View style={styles.container}>
            <Text>Contacts Module Example</Text>
        </View>
    );
}
const styles = StyleSheet.create({
    container: {
        flex: 1,
        backgroundColor: '#fff',
        alignItems: 'center',
        justifyContent: 'center',
    },
});
....................................................................................

Audio and video

expo install expo-av

import React, { useState, useRef } from 'react';
import { View, StyleSheet, Button } from 'react-native';
import { Video, AVPlaybackStatus } from 'expo-av';

export default function App() {
  const video = useRef(null);
  const [status, setStatus] = useState({});
  return (
    <View style={styles.container}>
      <Video
        ref={video}
        style={styles.video}
        source={{
          uri: 'http://d23dyxeqlo5psv.cloudfront.net/big_buck_bunny.mp4',
        }}
        useNativeControls
        resizeMode="contain"
        isLooping
        onPlaybackStatusUpdate={status => setStatus(() => status)}
      />
      <View style={styles.buttons}>
        <Button
          title={status.isPlaying ? 'Pause' : 'Play'}
          onPress={() =>
            status.isPlaying ? video.current.pauseAsync() : video.current.playAsync()
          }
        />
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    backgroundColor: '#ecf0f1',
  },
  video: {
    alignSelf: 'center',
    width: 320,
    height: 200,
  },
  buttons: {
    flexDirection: 'row',
    justifyContent: 'center',
    alignItems: 'center',
  },
});
....................................................................................
				Network

import * as Network from 'expo-network';
import React, { useEffect, useState } from 'react';
import { StyleSheet, View, Text } from 'react-native';

export default function App() {
    const [ip, setIp] = useState('')
    useEffect(() => {
        (async () => {
            const ip = await Network.getIpAddressAsync();
            console.log(ip)
            setIp(ip)
        })();
    }, []);

    return (
        <View style={styles.container}>
            <Text>Ip {ip}</Text>
        </View>
    );
}

const styles = StyleSheet.create({
    container: {
        flex: 1,
        backgroundColor: '#fff',
        alignItems: 'center',
        justifyContent: 'center',
    },
});
.....................................................................................
Storage: 

 How to store data in mobile device.

expo-sqlite gives your app access to a database that can be queried through a WebSQL-like API. The database is persisted across restarts of your app.

expo install expo-sqlite

How to use sqllite in our project?

import * as SQLite from 'expo-sqlite';

Database db = SQLite.openDatabase(name,version,desc,size)


Database Object methods

Database objects are returned by calls to SQLite.openDatabase(). Such an object represents a connection to a database on your device. They support one method:

db.transaction(callback, error, success)-Execute a database transaction.

A Transaction object is passed in as a parameter to the callback parameter for the db.transaction() method on a Database . It allows enqueuing SQL statements to perform in a database transaction. It supports one method:

tx.executeSql(sqlStatement, arguments, success, error)

ResultSet objects

ResultSet objects are returned through second parameter of the success callback for the tx.executeSql() method on a Transaction


import React, { useState } from 'react';
import { ScrollView, StyleSheet, Text, TextInput, TouchableOpacity, View } from 'react-native';
import Constants from 'expo-constants';
import * as SQLite from 'expo-sqlite';


const db = SQLite.openDatabase("db.db");

function Items({ done: doneHeading, onPressItem }) {
    const [items, setItems] = React.useState(null);

    React.useEffect(() => {
        db.transaction(tx => {
            tx.executeSql(
                `select * from items where done = ?;`,
                [doneHeading ? 1 : 0],
                (_, { rows: { _array } }) => setItems(_array)
            );
        });
    }, []);

    const heading = doneHeading ? "Completed" : "Todo";

    if (items === null || items.length === 0) {
        return null;
    }

    return (
        <View style={styles.sectionContainer}>
            <Text style={styles.sectionHeading}>{heading}</Text>
            {items.map(({ id, done, value }) => (
                <TouchableOpacity
                    key={id}
                    onPress={() => onPressItem && onPressItem(id)}
                    style={{
                        backgroundColor: done ? "#1c9963" : "#fff",
                        borderColor: "#000",
                        borderWidth: 1,
                        padding: 8
                    }}
                >
                    <Text style={{ color: done ? "#fff" : "#000" }}>{value}</Text>
                </TouchableOpacity>
            ))}
        </View>
    );
}

export default function App() {
    const [text, setText] = React.useState(null)
    const [forceUpdate, forceUpdateId] = useForceUpdate()

 

    React.useEffect(() => {
        db.transaction(tx => {
            tx.executeSql(
                "create table if not exists items (id integer primary key not null, done int, value text);"
            );
        });
    }, []);

    const add = (text) => {
        // is text empty?
        if (text === null || text === "") {
            return false;
        }

        db.transaction(
            tx => {
                tx.executeSql("insert into items (done, value) values (0, ?)", [text]);
                tx.executeSql("select * from items", [], (_, { rows }) =>
                    console.log(JSON.stringify(rows))
                );
            },
            null,
            forceUpdate
        );
    }

    return (
        <View style={styles.container}>
            <Text style={styles.heading}>SQLite Example</Text>
            <View style={styles.flexRow}>
                <TextInput
                    onChangeText={text => setText(text)}
                    onSubmitEditing={() => {
                        add(text);
                        setText(null);
                    }}
                    placeholder="what do you need to do?"
                    style={styles.input}
                    value={text}
                />
            </View>
            <ScrollView style={styles.listArea}>
                <Items
                    key={`forceupdate-todo-${forceUpdateId}`}
                    done={false}
                    onPressItem={id =>
                        db.transaction(
                            tx => {
                                tx.executeSql(`update items set done = 1 where id = ?;`, [
                                    id
                                ]);
                            },
                            null,
                            forceUpdate
                        )
                    }
                />
                <Items
                    done
                    key={`forceupdate-done-${forceUpdateId}`}
                    onPressItem={id =>
                        db.transaction(
                            tx => {
                                tx.executeSql(`delete from items where id = ?;`, [id]);
                            },
                            null,
                            forceUpdate
                        )
                    }
                />
            </ScrollView>
        </View>
    );

}

function useForceUpdate() {
    const [value, setValue] = useState(0);
    return [() => setValue(value + 1), value];
}

const styles = StyleSheet.create({
    container: {
        backgroundColor: "#fff",
        flex: 1,
        paddingTop: Constants.statusBarHeight
    },
    heading: {
        fontSize: 20,
        fontWeight: "bold",
        textAlign: "center"
    },
    flexRow: {
        flexDirection: "row"
    },
    input: {
        borderColor: "#4630eb",
        borderRadius: 4,
        borderWidth: 1,
        flex: 1,
        height: 48,
        margin: 16,
        padding: 8
    },
    listArea: {
        backgroundColor: "#f0f0f0",
        flex: 1,
        paddingTop: 16
    },
    sectionContainer: {
        marginBottom: 16,
        marginHorizontal: 16
    },
    sectionHeading: {
        fontSize: 18,
        marginBottom: 8
    }
});
.....................................................................................
				Sharing Files/data
....................................................................................

expo install expo-sharing
expo install image-picker

import React from 'react';
import { Image, StyleSheet, Text, TouchableOpacity, View } from 'react-native';
import * as ImagePicker from 'expo-image-picker';
import * as Sharing from 'expo-sharing';

export default function App() {
  let [selectedImage, setSelectedImage] = React.useState(null);

  let openImagePickerAsync = async () => {
    let permissionResult = await ImagePicker.requestCameraRollPermissionsAsync();

    if (permissionResult.granted === false) {
      alert('Permission to access camera roll is required!');
      return;
    }

    let pickerResult = await ImagePicker.launchImageLibraryAsync();
    if (pickerResult.cancelled === true) {
      return;
    }

    setSelectedImage({ localUri: pickerResult.uri });
  };

  let openShareDialogAsync = async () => {
    if (!(await Sharing.isAvailableAsync())) {
      alert(`Uh oh, sharing isn't available on your platform`);
      return;
    }

    await Sharing.shareAsync(selectedImage.localUri);
  };

  if (selectedImage !== null) {
    return (
      <View style={styles.container}>
        <Image source={{ uri: selectedImage.localUri }} style={styles.thumbnail} />
        <TouchableOpacity onPress={openShareDialogAsync} style={styles.button}>
          <Text style={styles.buttonText}>Share this photo</Text>
        </TouchableOpacity>
      </View>
    );
  }

  return (
    <View style={styles.container}>
      <Image source={{ uri: 'https://i.imgur.com/TkIrScD.png' }} style={styles.logo} />
      <Text style={styles.instructions}>
        To share a photo from your phone with a friend, just press the button below!
      </Text>

      <TouchableOpacity onPress={openImagePickerAsync} style={styles.button}>
        <Text style={styles.buttonText}>Pick a photo</Text>
      </TouchableOpacity>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#fff',
    alignItems: 'center',
    justifyContent: 'center',
  },
  logo: {
    width: 305,
    height: 159,
    marginBottom: 20,
  },
  instructions: {
    color: '#888',
    fontSize: 18,
    marginHorizontal: 15,
    marginBottom: 10,
  },
  button: {
    backgroundColor: 'blue',
    padding: 20,
    borderRadius: 5,
  },
  buttonText: {
    fontSize: 20,
    color: '#fff',
  },
  thumbnail: {
    width: 300,
    height: 300,
    resizeMode: 'contain',
  },
});
.....................................................................................
				Redux
.....................................................................................

Redux is nothing state management layer which maintains application global data.
Redux maintains data and biz logic.
UI Layer(React/ReactNative) receives data from the redux.

Redux core concepts:

1.Reducer :
   It is  a pure function, having state and biz logic
2.action :
   It is a request contains what to do 
3.dispatcher 
   It is a transporter which transports action object to the reducer
4.store
   It is a centeralized place where all application data is stored.


Steps:
1.redux logic

2.react logic

React Native With Router + Redux

import { Provider, useSelector, useDispatch } from 'react-redux'
import { createSlice, configureStore } from '@reduxjs/toolkit'
import { StyleSheet, Text, View } from 'react-native';
import { Button } from 'react-native';
import { NavigationContainer } from '@react-navigation/native';
import { createNativeStackNavigator } from '@react-navigation/native-stack';

const Stack = createNativeStackNavigator()

//application logic 
const counterReducer = (state = { value: 10 }, action) => {
    //biz logic
    switch (action.type) {
        case 'counter/increment':
            return { ...state, value: state.value + 1 }
        default:
            return state;
    }
}

export const store = configureStore({
    reducer: counterReducer
})

const CounterScreen = props => {
    const value = useSelector(state => {
        console.log(state)
        return state.value
    })
    const dispatch = useDispatch()

    return <View style={styles.container}>
        <Text>React Native Redux</Text>
        <Text>Value : {value}</Text>
        <Button title="+" onPress={() => {
            //send an action to store
            dispatch({
                type: 'counter/increment'
            })
        }} />
    </View>
}

const Root = () => <Provider store={store}>
    <NavigationContainer>
        <Stack.Navigator>
            <Stack.Screen name="Counter"  component={CounterScreen} />
        </Stack.Navigator>
    </NavigationContainer>
</Provider>
//react native: UI logic
export default App = () => {
    return <Root />
}

const styles = StyleSheet.create({
    container: {
        flex: 1,
        backgroundColor: '#fff',
        alignItems: 'center',
        justifyContent: 'center',
    },
});





























